/**
 * Friends Page (Protected Route)
 *
 * Displays a combined view of followers and following with tabs.
 * Uses client-side React Query for data fetching.
 *
 * @see Sidebar navigation - Friends link
 */

import { useQueryClient } from '@tanstack/react-query';
import { createFileRoute, Link, Navigate } from '@tanstack/react-router';
import { UserMinus, UserPlus, Users } from 'lucide-react';
import { toast } from 'sonner';

import type { FollowerResponse, SessionUserResponse } from '@/api/generated.schemas';
import type {
  getUserFollowersApiV1UsersUsernameFollowersGetResponse,
  getUserFollowingApiV1UsersUsernameFollowingGetResponse,
} from '@/api/users/users';

import {
  getGetUserFollowersApiV1UsersUsernameFollowersGetQueryKey,
  getGetUserFollowingApiV1UsersUsernameFollowingGetQueryKey,
  useFollowUserApiV1UsersUsernameFollowPost,
  useGetUserFollowersApiV1UsersUsernameFollowersGet,
  useGetUserFollowingApiV1UsersUsernameFollowingGet,
  useUnfollowUserApiV1UsersUsernameFollowDelete,
} from '@/api/users/users';
import { DashboardLayout } from '@/components/dashboard-layout';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { handleLogout, useUser } from '@/lib/auth/client';

export const Route = createFileRoute('/friends')({
  component: FriendsPage,
  head: () => ({
    meta: [
      {
        title: 'Friends - burntop.dev',
      },
      {
        name: 'description',
        content: 'View and manage your followers and the people you follow on burntop.dev.',
      },
    ],
  }),
});

function FriendsPage() {
  const { user, isLoading } = useUser();
  const queryClient = useQueryClient();

  // Type the user data properly - useUser returns SessionUserResponse | null
  // SessionUserResponse has required fields: id, email, username, email_verified, is_public, created_at, updated_at
  // and optional fields: name, image
  const userTyped = user as SessionUserResponse | null;

  // Derive username for API calls - username is required in SessionUserResponse when user is authenticated
  // Fall back to 'unknown' only when user is null (loading/unauthenticated state)
  const username = userTyped?.username ?? 'unknown';

  // Determine if queries should be enabled - only when user is authenticated
  // This prevents API calls with 'unknown' username before auth is complete
  const isAuthenticated = !isLoading && !!user;

  // Fetch followers and following using Orval-generated React Query hooks
  // These must be called unconditionally (before any returns)
  // Queries are disabled until user is authenticated to prevent invalid API calls
  // Note: Type assertion needed as Orval-generated types require queryKey, but it's auto-generated by the hook
  const followersQuery = useGetUserFollowersApiV1UsersUsernameFollowersGet(username, undefined, {
    // @ts-expect-error - queryKey is auto-generated by the hook, but TS types require it
    query: { enabled: isAuthenticated },
  });
  const followingQuery = useGetUserFollowingApiV1UsersUsernameFollowingGet(username, undefined, {
    // @ts-expect-error - queryKey is auto-generated by the hook, but TS types require it
    query: { enabled: isAuthenticated },
  });

  // Query keys for invalidation - only generate valid keys when user is authenticated
  // When unauthenticated, use empty arrays as placeholder keys (queries won't run anyway)
  // This ensures mutation optimistic updates and invalidations use correct keys
  const followersQueryKey = isAuthenticated
    ? getGetUserFollowersApiV1UsersUsernameFollowersGetQueryKey(username)
    : [];
  const followingQueryKey = isAuthenticated
    ? getGetUserFollowingApiV1UsersUsernameFollowingGetQueryKey(username)
    : [];

  // Follow mutation with optimistic updates
  const followMutation = useFollowUserApiV1UsersUsernameFollowPost({
    mutation: {
      onMutate: async ({ username: targetUsername }) => {
        // Cancel any outgoing refetches to avoid overwriting optimistic update
        await queryClient.cancelQueries({ queryKey: followingQueryKey });

        // Snapshot the previous value for rollback
        const previousFollowing = queryClient.getQueryData(followingQueryKey);

        // Optimistically update the following list
        queryClient.setQueryData(
          followingQueryKey,
          (old: getUserFollowingApiV1UsersUsernameFollowingGetResponse | undefined) => {
            if (!old || old.status !== 200) return old;
            // Find the user in followers list to add to following
            const followersResponse = queryClient.getQueryData(followersQueryKey) as
              | getUserFollowersApiV1UsersUsernameFollowersGetResponse
              | undefined;
            const targetUser =
              followersResponse?.status === 200
                ? followersResponse.data.items?.find((u) => u.username === targetUsername)
                : undefined;

            if (targetUser && old.data.items) {
              return {
                ...old,
                data: {
                  ...old.data,
                  items: [...old.data.items, targetUser],
                  total: (old.data.total || 0) + 1,
                },
              };
            }
            return old;
          }
        );

        return { previousFollowing };
      },
      onError: (_err, _variables, context) => {
        // Rollback on error
        if (context?.previousFollowing) {
          queryClient.setQueryData(followingQueryKey, context.previousFollowing);
        }
        toast.error('Failed to follow user');
      },
      onSuccess: () => {
        toast.success('Following successfully');
      },
      onSettled: () => {
        queryClient.invalidateQueries({ queryKey: followersQueryKey });
        queryClient.invalidateQueries({ queryKey: followingQueryKey });
      },
    },
  });

  // Unfollow mutation with optimistic updates
  const unfollowMutation = useUnfollowUserApiV1UsersUsernameFollowDelete({
    mutation: {
      onMutate: async ({ username: targetUsername }) => {
        // Cancel any outgoing refetches to avoid overwriting optimistic update
        await queryClient.cancelQueries({ queryKey: followingQueryKey });

        // Snapshot the previous value for rollback
        const previousFollowing = queryClient.getQueryData(followingQueryKey);

        // Optimistically remove user from following list
        queryClient.setQueryData(
          followingQueryKey,
          (old: getUserFollowingApiV1UsersUsernameFollowingGetResponse | undefined) => {
            if (!old || old.status !== 200 || !old.data.items) return old;
            return {
              ...old,
              data: {
                ...old.data,
                items: old.data.items.filter((u) => u.username !== targetUsername),
                total: Math.max((old.data.total || 1) - 1, 0),
              },
            };
          }
        );

        return { previousFollowing };
      },
      onError: (_err, _variables, context) => {
        // Rollback on error
        if (context?.previousFollowing) {
          queryClient.setQueryData(followingQueryKey, context.previousFollowing);
        }
        toast.error('Failed to unfollow user');
      },
      onSuccess: () => {
        toast.success('Unfollowed successfully');
      },
      onSettled: () => {
        queryClient.invalidateQueries({ queryKey: followersQueryKey });
        queryClient.invalidateQueries({ queryKey: followingQueryKey });
      },
    },
  });

  // Show loading state while checking authentication
  if (isLoading) {
    return (
      <DashboardLayout user={undefined} onSignOut={() => handleLogout('/')}>
        <div className="px-4 py-8">
          <div className="max-w-4xl mx-auto">
            <div className="mb-8">
              <div className="h-9 w-32 bg-bg-elevated rounded animate-pulse mb-2" />
              <div className="h-5 w-48 bg-bg-elevated rounded animate-pulse" />
            </div>
            <div className="space-y-3">
              {[...Array(5)].map((_, i) => (
                <div key={i} className="h-24 bg-bg-elevated rounded-lg animate-pulse" />
              ))}
            </div>
          </div>
        </div>
      </DashboardLayout>
    );
  }

  // Redirect to login if not authenticated (only after loading completes)
  if (!user) {
    return <Navigate to="/login" search={{ error: undefined, error_description: undefined }} />;
  }

  // Extract paginated data from query responses
  // The Orval-generated hooks return { data, status, headers } where data is PageUserPublicResponse
  const followersResponse = followersQuery.data as
    | getUserFollowersApiV1UsersUsernameFollowersGetResponse
    | undefined;
  const followingResponse = followingQuery.data as
    | getUserFollowingApiV1UsersUsernameFollowingGetResponse
    | undefined;

  const followersPageData = followersResponse?.status === 200 ? followersResponse.data : undefined;
  const followingPageData = followingResponse?.status === 200 ? followingResponse.data : undefined;

  const followersItems = followersPageData?.items || [];
  const followingItems = followingPageData?.items || [];

  const followerCount = followersPageData?.total || 0;
  const followingCount = followingPageData?.total || 0;

  // Get the IDs of users we follow to mark mutual follows
  const followingIds = new Set(followingItems.map((u) => u.id));

  // Mark followers who we also follow (mutual)
  const followers = followersItems.map((follower) => ({
    ...follower,
    isFollowing: followingIds.has(follower.id),
  }));

  const following = followingItems.map((f) => ({
    ...f,
    isFollowing: true,
  }));

  // Prepare user data for TopNav
  // userTyped is safe to access here as we've already checked !user above
  const topNavUser = {
    name: userTyped?.name || userTyped?.email || 'Unknown',
    username,
    avatarUrl: userTyped?.image || undefined,
  };

  // Get initials for avatar fallback
  const getInitials = (name: string | null | undefined): string => {
    if (!name) return '?';
    return name
      .split(' ')
      .map((n) => n[0])
      .join('')
      .toUpperCase()
      .slice(0, 2);
  };

  // Handle follow/unfollow action - mutations handle optimistic updates
  const handleFollowToggle = (
    targetUser: FollowerResponse & { isFollowing?: boolean },
    isCurrentlyFollowing: boolean
  ) => {
    // Use mutate (not mutateAsync) for fire-and-forget with optimistic updates
    // The mutation's onMutate/onError/onSuccess handlers manage all state
    if (isCurrentlyFollowing) {
      unfollowMutation.mutate({ username: targetUser.username });
    } else {
      followMutation.mutate({ username: targetUser.username });
    }
  };

  const renderUserCard = (
    friendUser: FollowerResponse & { isFollowing?: boolean },
    showFollowButton: boolean = false
  ) => {
    const isFollowingUser = friendUser.isFollowing ?? false;
    // Disable button while mutation is pending for this specific user
    const isMutationPending =
      (followMutation.isPending && followMutation.variables?.username === friendUser.username) ||
      (unfollowMutation.isPending && unfollowMutation.variables?.username === friendUser.username);

    return (
      <Card key={friendUser.id} className="bg-bg-elevated border-border-default">
        <CardContent className="py-4">
          <div className="flex items-center gap-4">
            {/* Avatar */}
            <Link
              to="/p/$username"
              params={{
                username: friendUser.username,
              }}
            >
              <Avatar className="h-12 w-12 cursor-pointer hover:opacity-80 transition-opacity">
                <AvatarImage
                  src={friendUser.image || undefined}
                  alt={friendUser.name || undefined}
                />
                <AvatarFallback className="bg-bg-surface text-text-primary">
                  {getInitials(friendUser.name)}
                </AvatarFallback>
              </Avatar>
            </Link>

            {/* User Info */}
            <div className="flex-1 min-w-0">
              <Link
                to="/p/$username"
                params={{
                  username: friendUser.username,
                }}
                className="hover:underline hover:text-ember-500 transition-colors"
              >
                <h3 className="text-text-primary font-semibold truncate">{friendUser.name}</h3>
              </Link>
              <p className="text-sm text-text-secondary">@{friendUser.username}</p>
              {friendUser.bio && (
                <p className="text-sm text-text-secondary mt-1 line-clamp-1">{friendUser.bio}</p>
              )}
            </div>

            {/* Action Buttons */}
            <div className="flex items-center gap-2">
              {showFollowButton && (
                <Button
                  variant={isFollowingUser ? 'outline' : 'default'}
                  size="sm"
                  onClick={() => handleFollowToggle(friendUser, isFollowingUser)}
                  disabled={isMutationPending}
                >
                  {isFollowingUser ? (
                    <>
                      <UserMinus className="h-4 w-4 mr-1" />
                      Unfollow
                    </>
                  ) : (
                    <>
                      <UserPlus className="h-4 w-4 mr-1" />
                      Follow
                    </>
                  )}
                </Button>
              )}
              <Button asChild variant="outline" size="sm">
                <Link
                  to="/p/$username"
                  params={{
                    username: friendUser.username,
                  }}
                >
                  View
                </Link>
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>
    );
  };

  const renderEmptyState = (type: 'followers' | 'following') => (
    <Card className="bg-bg-elevated border-border-default">
      <CardContent className="py-12">
        <div className="flex flex-col items-center justify-center gap-4">
          {type === 'followers' ? (
            <Users className="h-12 w-12 text-text-tertiary" />
          ) : (
            <UserPlus className="h-12 w-12 text-text-tertiary" />
          )}
          <div className="text-center">
            <h3 className="text-lg font-semibold text-text-primary mb-2">
              {type === 'followers' ? 'No followers yet' : 'Not following anyone yet'}
            </h3>
            <p className="text-text-secondary max-w-sm">
              {type === 'followers'
                ? 'Share your profile and achievements to grow your follower base!'
                : 'Discover other developers on the leaderboard and follow them to see their progress!'}
            </p>
          </div>
          <Button asChild variant="default" className="mt-4">
            <Link to="/leaderboard">Explore Leaderboard</Link>
          </Button>
        </div>
      </CardContent>
    </Card>
  );

  return (
    <DashboardLayout user={topNavUser} onSignOut={() => handleLogout('/')}>
      <div className="px-4 py-8">
        <div className="max-w-4xl mx-auto">
          {/* Header */}
          <div className="mb-8">
            <h1 className="text-3xl font-bold text-text-primary mb-2">Friends</h1>
            <p className="text-text-secondary">
              {followerCount} {followerCount === 1 ? 'follower' : 'followers'} Â· {followingCount}{' '}
              following
            </p>
          </div>

          {/* Tabs */}
          <Tabs defaultValue="following" className="w-full">
            <TabsList className="mb-6">
              <TabsTrigger value="following">
                <UserPlus className="h-4 w-4 mr-2" />
                Following ({following.length})
              </TabsTrigger>
              <TabsTrigger value="followers">
                <Users className="h-4 w-4 mr-2" />
                Followers ({followers.length})
              </TabsTrigger>
            </TabsList>

            <TabsContent value="following">
              {following.length === 0 ? (
                renderEmptyState('following')
              ) : (
                <div className="space-y-3">
                  {following.map((followedUser) => renderUserCard(followedUser, true))}
                </div>
              )}
            </TabsContent>

            <TabsContent value="followers">
              {followers.length === 0 ? (
                renderEmptyState('followers')
              ) : (
                <div className="space-y-3">
                  {followers.map((follower) => renderUserCard(follower, true))}
                </div>
              )}
            </TabsContent>
          </Tabs>
        </div>
      </div>
    </DashboardLayout>
  );
}
