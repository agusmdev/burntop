/**
 * Generated by orval v7.18.0 üç∫
 * Do not edit manually.
 * Burntop API
 * OpenAPI spec version: 0.1.0
 */
/**
 * Achievement icon URL
 */
export type AchievementUnlockResponseIconUrl = string | null;

/**
 * Achievement unlock notification in sync response.
 */
export interface AchievementUnlockResponse {
  /** Achievement ID */
  id: string;
  /** Achievement name */
  name: string;
  /** Achievement description */
  description: string;
  /** Achievement category */
  category: string;
  /** Achievement rarity level */
  rarity: string;
  /** XP awarded for this achievement */
  xp_reward: number;
  /**
   * Tier level (1-5: Bronze, Silver, Gold, Platinum, Diamond)
   * @minimum 1
   * @maximum 5
   */
  tier?: number;
  /** Achievement icon URL */
  icon_url?: AchievementUnlockResponseIconUrl;
}

export type ActivityResponseDataAnyOf = { [key: string]: unknown };

/**
 * Additional type-specific data
 */
export type ActivityResponseData = ActivityResponseDataAnyOf | null;

/**
 * User who performed the activity (for feed display)
 */
export type ActivityResponseUser = UserMinimalResponse | null;

/**
 * Schema for activity response.

Includes all activity fields plus user information for display in feeds.
 */
export interface ActivityResponse {
  id: string;
  created_at: string;
  updated_at: string;
  /** ID of the user who performed the activity */
  user_id: string;
  /** Type of activity */
  type: string;
  /** Additional type-specific data */
  data?: ActivityResponseData;
  /** User who performed the activity (for feed display) */
  user?: ActivityResponseUser;
}

/**
 * Comparison response for two users.

Contains comparison data for both users.
 */
export interface ComparisonResponse {
  id: string;
  created_at: string;
  updated_at: string;
  user_a: UserComparisonDataResponse;
  user_b: UserComparisonDataResponse;
}

/**
 * Daily trend data point for charts.
 */
export interface DailyTrendData {
  /** Date of the data point */
  date: string;
  /** Total tokens for the day */
  tokens: number;
  /** Total cost in USD for the day */
  cost: number;
  /** Input tokens for the day */
  input_tokens?: number;
  /** Output tokens for the day */
  output_tokens?: number;
  /** Cache read tokens for the day */
  cache_read_tokens?: number;
  /** Cache write tokens for the day */
  cache_write_tokens?: number;
  /** Reasoning tokens for the day */
  reasoning_tokens?: number;
}

/**
 * Dashboard models breakdown.

Aggregated usage by AI model for visualization.
 */
export interface DashboardModelsResponse {
  /** Usage breakdown by model */
  models: ModelUsageData[];
  /** Total unique models used */
  total_models: number;
}

/**
 * AI Native tier badge (Power User, AI Native, Token Titan) based on 30-day usage
 */
export type DashboardOverviewResponseMonthlyBadge = string | null;

/**
 * Dashboard overview statistics.

Aggregated stats for user's overall activity and usage.
 */
export interface DashboardOverviewResponse {
  /** Total tokens across all usage */
  total_tokens: number;
  /** Total input tokens */
  total_input_tokens: number;
  /** Total output tokens */
  total_output_tokens: number;
  /** Total cache read tokens */
  total_cache_read_tokens: number;
  /** Total cache write tokens */
  total_cache_write_tokens: number;
  /** Total reasoning tokens */
  total_reasoning_tokens: number;
  /** Total cost in USD */
  total_cost: number;
  /** Current consecutive days streak */
  current_streak: number;
  /** Longest streak achieved */
  longest_streak: number;
  /** Total tokens for last 30 days (rolling window) */
  monthly_tokens: number;
  /** AI Native tier badge (Power User, AI Native, Token Titan) based on 30-day usage */
  monthly_badge?: DashboardOverviewResponseMonthlyBadge;
  /** Total days with usage */
  unique_days: number;
  /** Number of unique models used */
  unique_models: number;
  /** Number of unique sources used */
  unique_sources: number;
  /** Average cache efficiency percentage (0-100) */
  cache_efficiency: number;
}

/**
 * Dashboard tools/sources breakdown.

Aggregated usage by source/tool for visualization.
 */
export interface DashboardToolsResponse {
  /** Usage breakdown by source/tool */
  tools: ToolUsageData[];
  /** Total unique tools/sources used */
  total_tools: number;
}

/**
 * Dashboard trends over time.

Daily usage data for charting and trend analysis.
 */
export interface DashboardTrendsResponse {
  /** Daily usage data points */
  daily_data: DailyTrendData[];
  /** Start date of the period */
  period_start: string;
  /** End date of the period */
  period_end: string;
}

/**
 * Debug entry for ranking preview.
 */
export interface DebugRankingEntry {
  /** User's UUID */
  user_id: string;
  /**
   * Total tokens used
   * @minimum 0
   */
  total_tokens: number;
  /**
   * Rank by token usage
   * @minimum 1
   */
  rank: number;
}

/**
 * Response schema for debug stats endpoint.
 */
export interface DebugStatsResponse {
  /**
   * Total usage records in database
   * @minimum 0
   */
  usage_record_count: number;
  /**
   * Number of unique users with usage data
   * @minimum 0
   */
  unique_users: number;
  /** Top users by token usage */
  top_users: DebugRankingEntry[];
  /**
   * Number of leaderboard cache entries
   * @minimum 0
   */
  cache_entry_count: number;
}

/**
 * Request schema for device flow token exchange.

Used by CLI to exchange a GitHub access token for a burntop session.
 */
export interface DeviceTokenExchangeRequest {
  /** GitHub access token from device flow */
  access_token: string;
}

/**
 * Schema for Follow response.

Represents a follow relationship between two users.
 */
export interface FollowResponse {
  /** ID of the user who is following */
  follower_id: string;
  /** ID of the user being followed */
  following_id: string;
  /** Timestamp when the follow relationship was created */
  created_at: string;
}

/**
 * Whether the current user is following this user (requires authentication)
 */
export type FollowStatsResponseIsFollowing = boolean | null;

/**
 * Whether this user is following the current user (requires authentication)
 */
export type FollowStatsResponseFollowsMe = boolean | null;

/**
 * Schema for follow statistics.

Contains follower and following counts for a user.
 */
export interface FollowStatsResponse {
  /** Number of followers */
  followers_count: number;
  /** Number of users being followed */
  following_count: number;
  /** Whether the current user is following this user (requires authentication) */
  is_following?: FollowStatsResponseIsFollowing;
  /** Whether this user is following the current user (requires authentication) */
  follows_me?: FollowStatsResponseFollowsMe;
}

/**
 * Display name
 */
export type FollowerResponseName = string | null;

/**
 * Profile image URL
 */
export type FollowerResponseImage = string | null;

/**
 * User bio
 */
export type FollowerResponseBio = string | null;

/**
 * Schema for follower/following user information.

Used when displaying lists of followers or following users.
Includes basic user information.
 */
export interface FollowerResponse {
  /** User ID */
  id: string;
  /** Username */
  username: string;
  /** Display name */
  name?: FollowerResponseName;
  /** Profile image URL */
  image?: FollowerResponseImage;
  /** User bio */
  bio?: FollowerResponseBio;
  /** Timestamp when the follow relationship was created */
  followed_at: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * Individual health check result.
 */
export interface HealthCheckResponse {
  /** Database connection status: 'ok' or 'error' */
  database: string;
}

/**
 * Overall health check response for uptime monitoring services.
 */
export interface HealthResponse {
  /** Overall service status: 'ok' or 'degraded' */
  status: string;
  /** UTC timestamp of the health check */
  timestamp: string;
  /** Individual service health checks */
  checks: HealthCheckResponse;
}

export type InsightsResponseUserCacheEfficiency = number | null;

export type InsightsResponseCommunityAvgTokens = number | null;

export type InsightsResponseCommunityMedianTokens = number | null;

export type InsightsResponseCommunityAvgCost = number | null;

export type InsightsResponseCommunityAvgStreak = number | null;

export type InsightsResponseCommunityAvgUniqueTools = number | null;

export type InsightsResponseCommunityAvgCacheEfficiency = number | null;

/**
 * User's percentile for total tokens
 */
export type InsightsResponseTokensPercentile = number | null;

/**
 * User's percentile for total cost
 */
export type InsightsResponseCostPercentile = number | null;

/**
 * User's percentile for current streak
 */
export type InsightsResponseStreakPercentile = number | null;

/**
 * User's percentile for unique tools
 */
export type InsightsResponseToolsPercentile = number | null;

/**
 * User's percentile for cache efficiency
 */
export type InsightsResponseCacheEfficiencyPercentile = number | null;

/**
 * User insights response comparing user stats to community benchmarks.

Provides percentile rankings and comparative metrics to help users
understand how they compare to the broader community.
 */
export interface InsightsResponse {
  id: string;
  created_at: string;
  updated_at: string;
  username: string;
  /** Period for the comparison (all, month, week) */
  period: string;
  user_total_tokens: number;
  user_total_cost: number;
  user_current_streak: number;
  user_unique_tools: number;
  user_cache_efficiency: InsightsResponseUserCacheEfficiency;
  user_unique_days: number;
  community_avg_tokens: InsightsResponseCommunityAvgTokens;
  community_median_tokens: InsightsResponseCommunityMedianTokens;
  community_avg_cost: InsightsResponseCommunityAvgCost;
  community_avg_streak: InsightsResponseCommunityAvgStreak;
  community_avg_unique_tools: InsightsResponseCommunityAvgUniqueTools;
  community_avg_cache_efficiency: InsightsResponseCommunityAvgCacheEfficiency;
  community_total_users: number;
  /** User's percentile for total tokens */
  tokens_percentile?: InsightsResponseTokensPercentile;
  /** User's percentile for total cost */
  cost_percentile?: InsightsResponseCostPercentile;
  /** User's percentile for current streak */
  streak_percentile?: InsightsResponseStreakPercentile;
  /** User's percentile for unique tools */
  tools_percentile?: InsightsResponseToolsPercentile;
  /** User's percentile for cache efficiency */
  cache_efficiency_percentile?: InsightsResponseCacheEfficiencyPercentile;
  /** Whether user's token usage is above community average. */
  readonly is_above_average_tokens: boolean;
  /** Whether user's streak is above community average. */
  readonly is_above_average_streak: boolean;
  /** Whether user's cache efficiency is above community average. */
  readonly is_above_average_cache_efficiency: boolean;
}

/**
 * User's display name (if set)
 */
export type LeaderboardEntryResponseDisplayName = string | null;

/**
 * User's profile image URL
 */
export type LeaderboardEntryResponseImage = string | null;

/**
 * Rank change since last update (positive = improved)
 */
export type LeaderboardEntryResponseRankChange = number | null;

/**
 * Total cost in USD
 */
export type LeaderboardEntryResponseTotalCost = number | null;

/**
 * Current streak in days
 */
export type LeaderboardEntryResponseStreakDays = number | null;

/**
 * User's most used tool (by token count)
 */
export type LeaderboardEntryResponsePreferredTool = string | null;

/**
 * Whether the current user is following this user (null if not authenticated)
 */
export type LeaderboardEntryResponseIsFollowing = boolean | null;

/**
 * Response schema for a single leaderboard entry.
 */
export interface LeaderboardEntryResponse {
  id: string;
  created_at: string;
  updated_at: string;
  /** User's UUID */
  user_id: string;
  /** User's username */
  username: string;
  /** User's display name (if set) */
  display_name?: LeaderboardEntryResponseDisplayName;
  /** User's profile image URL */
  image?: LeaderboardEntryResponseImage;
  /**
   * Current rank on leaderboard
   * @minimum 1
   */
  rank: number;
  /** Rank change since last update (positive = improved) */
  rank_change?: LeaderboardEntryResponseRankChange;
  /**
   * Total tokens used
   * @minimum 0
   */
  total_tokens: number;
  /** Total cost in USD */
  total_cost?: LeaderboardEntryResponseTotalCost;
  /** Current streak in days */
  streak_days?: LeaderboardEntryResponseStreakDays;
  /** User's most used tool (by token count) */
  preferred_tool?: LeaderboardEntryResponsePreferredTool;
  /**
   * Number of followers
   * @minimum 0
   */
  followers_count?: number;
  /** Whether the current user is following this user (null if not authenticated) */
  is_following?: LeaderboardEntryResponseIsFollowing;
}

/**
 * Paginated leaderboard response with metadata.
 */
export interface LeaderboardResponse {
  /** List of leaderboard entries */
  entries: LeaderboardEntryResponse[];
  /** Pagination information */
  pagination: PaginationMeta;
  /** Time period (all, month, week) */
  period: string;
  /** Sort field (tokens, cost, streak) */
  sort_by: string;
}

/**
 * Request schema for email/password login.

Validates email format and requires both fields.
 */
export interface LoginRequest {
  /** User email address */
  email: string;
  /**
   * User password (min 8 chars)
   * @minLength 8
   */
  password: string;
}

/**
 * Model usage breakdown.
 */
export interface ModelUsageData {
  /** Model identifier */
  model: string;
  /** Total tokens for this model */
  tokens: number;
  /** Total cost in USD for this model */
  cost: number;
  /** Percentage of total usage (0-100) */
  percentage: number;
  /** Number of days this model was used */
  days_active: number;
}

export interface PageActivityResponse {
  items: ActivityResponse[];
  /** @minimum 0 */
  total: number;
  /** @minimum 1 */
  page: number;
  /** @minimum 1 */
  size: number;
  /** @minimum 0 */
  pages: number;
}

export interface PageFollowerResponse {
  items: FollowerResponse[];
  /** @minimum 0 */
  total: number;
  /** @minimum 1 */
  page: number;
  /** @minimum 1 */
  size: number;
  /** @minimum 0 */
  pages: number;
}

/**
 * Pagination metadata for leaderboard responses.
 */
export interface PaginationMeta {
  /**
   * Total number of entries
   * @minimum 0
   */
  total: number;
  /**
   * Entries per page
   * @minimum 1
   */
  limit: number;
  /**
   * Current offset
   * @minimum 0
   */
  offset: number;
  /** Whether there are more results */
  has_more: boolean;
}

/**
 * Platform-wide statistics for public display.

Used on the landing page to show aggregate platform metrics.
 */
export interface PlatformStatsResponse {
  /** Total tokens tracked across all users */
  total_tokens: number;
  /** Total number of active users on the platform */
  total_users: number;
  /** Number of AI tools supported */
  total_tools: number;
}

/**
 * Optional custom title (overrides OG title)
 */
export type ProjectCreateTitle = string | null;

/**
 * Optional custom description (overrides OG description)
 */
export type ProjectCreateDescription = string | null;

/**
 * Schema for creating a new project.

Only the URL is required - OG metadata will be fetched automatically.
User can optionally provide title/description to override OG values.
 */
export interface ProjectCreate {
  /**
   * Project URL (must be a valid http/https URL)
   * @minLength 1
   * @maxLength 2048
   */
  url: string;
  /** Optional custom title (overrides OG title) */
  title?: ProjectCreateTitle;
  /** Optional custom description (overrides OG description) */
  description?: ProjectCreateDescription;
  /** Whether this project should be featured prominently */
  is_featured?: boolean;
  /**
   * Display order for sorting projects
   * @minimum 0
   */
  display_order?: number;
}

export type ProjectResponseTitle = string | null;

export type ProjectResponseDescription = string | null;

export type ProjectResponseOgImageUrl = string | null;

export type ProjectResponseOgDescription = string | null;

export type ProjectResponseFaviconUrl = string | null;

/**
 * Full project response schema.

Includes all project fields for API responses.
 */
export interface ProjectResponse {
  id: string;
  created_at: string;
  updated_at: string;
  user_id: string;
  url: string;
  title: ProjectResponseTitle;
  description: ProjectResponseDescription;
  og_image_url: ProjectResponseOgImageUrl;
  og_description: ProjectResponseOgDescription;
  favicon_url: ProjectResponseFaviconUrl;
  is_featured: boolean;
  display_order: number;
}

/**
 * Project URL
 */
export type ProjectUpdateUrl = string | null;

/**
 * Custom title
 */
export type ProjectUpdateTitle = string | null;

/**
 * Custom description
 */
export type ProjectUpdateDescription = string | null;

/**
 * Open Graph image URL (auto-fetched from URL)
 */
export type ProjectUpdateOgImageUrl = string | null;

/**
 * Open Graph description (auto-fetched from URL)
 */
export type ProjectUpdateOgDescription = string | null;

/**
 * Favicon URL (auto-fetched from URL)
 */
export type ProjectUpdateFaviconUrl = string | null;

/**
 * Whether this project should be featured
 */
export type ProjectUpdateIsFeatured = boolean | null;

/**
 * Display order for sorting
 */
export type ProjectUpdateDisplayOrder = number | null;

/**
 * Schema for updating a project.

All fields optional for PATCH operations.
 */
export interface ProjectUpdate {
  /** Project URL */
  url?: ProjectUpdateUrl;
  /** Custom title */
  title?: ProjectUpdateTitle;
  /** Custom description */
  description?: ProjectUpdateDescription;
  /** Open Graph image URL (auto-fetched from URL) */
  og_image_url?: ProjectUpdateOgImageUrl;
  /** Open Graph description (auto-fetched from URL) */
  og_description?: ProjectUpdateOgDescription;
  /** Favicon URL (auto-fetched from URL) */
  favicon_url?: ProjectUpdateFaviconUrl;
  /** Whether this project should be featured */
  is_featured?: ProjectUpdateIsFeatured;
  /** Display order for sorting */
  display_order?: ProjectUpdateDisplayOrder;
}

export interface RefreshResponse {
  success: boolean;
  message: string;
}

/**
 * Display name
 */
export type RegisterRequestName = string | null;

/**
 * Request schema for user registration.

Validates:
- Email format (EmailStr)
- Password length (min 8 chars)
- Username format (3-30 chars, alphanumeric + underscore)
- Name (optional, max 100 chars)
 */
export interface RegisterRequest {
  /** User email address */
  email: string;
  /**
   * User password (min 8 chars)
   * @minLength 8
   */
  password: string;
  /**
   * Username (alphanumeric and underscore only)
   * @minLength 3
   * @maxLength 30
   * @pattern ^[a-zA-Z0-9_]+$
   */
  username: string;
  /** Display name */
  name?: RegisterRequestName;
}

/**
 * Response schema for session information.

Includes computed `expires_in` field for client-side expiration handling.
Note: Session uses string ID (not UUID) due to custom format: s_{token}.
 */
export interface SessionResponse {
  /** Session ID (e.g., s_...) */
  id: string;
  /** User ID associated with session */
  user_id: string;
  /** Bearer token for authentication */
  token: string;
  /** Expiration timestamp */
  expires_at: string;
  /** Session creation timestamp */
  created_at: string;
}

/**
 * Display name
 */
export type SessionUserResponseName = string | null;

/**
 * Profile image URL
 */
export type SessionUserResponseImage = string | null;

/**
 * Response schema for authenticated user from session check.

Used by check_session to return user information without
exposing the SQLAlchemy model.
 */
export interface SessionUserResponse {
  /** User ID */
  id: string;
  /** User email address */
  email: string;
  /** Whether email is verified */
  email_verified: boolean;
  /** Username */
  username: string;
  /** Display name */
  name?: SessionUserResponseName;
  /** Profile image URL */
  image?: SessionUserResponseImage;
  /** Whether profile is public */
  is_public: boolean;
  /** User creation timestamp */
  created_at: string;
  /** User last update timestamp */
  updated_at: string;
}

/**
 * Number of messages/interactions
 */
export type SyncRecordRequestMessageCount = number | null;

/**
 * Individual usage record in sync request payload.

Aggregated by date, source, and model for efficiency.
Received from CLI clients during sync operation.
 */
export interface SyncRecordRequest {
  /** Date of usage (YYYY-MM-DD) */
  date: string;
  /**
   * Source tool identifier (e.g., cursor, claude-code)
   * @minLength 1
   * @maxLength 50
   */
  source: string;
  /**
   * Model identifier (e.g., claude-3-5-sonnet-20241022)
   * @minLength 1
   * @maxLength 100
   */
  model: string;
  /**
   * Input tokens used
   * @minimum 0
   */
  inputTokens?: number;
  /**
   * Output tokens used
   * @minimum 0
   */
  outputTokens?: number;
  /**
   * Cache read tokens
   * @minimum 0
   */
  cacheReadTokens?: number;
  /**
   * Cache write tokens
   * @minimum 0
   */
  cacheCreationTokens?: number;
  /**
   * Reasoning tokens used
   * @minimum 0
   */
  reasoningTokens?: number;
  /** Number of messages/interactions */
  messageCount?: SyncRecordRequestMessageCount;
}

/**
 * Sync request payload from CLI.

Contains metadata and list of usage records to sync.
 */
export interface SyncRequest {
  /** Sync payload format version */
  version: string;
  /** Client identifier (e.g., burntop-cli) */
  client: string;
  /**
   * Machine identifier for multi-machine sync
   * @minLength 1
   * @maxLength 50
   */
  machineId?: string;
  /** Timestamp when sync was initiated */
  syncedAt: string;
  /** Usage records to sync */
  records: SyncRecordRequest[];
}

/**
 * Optional message
 */
export type SyncResponseMessage = string | null;

/**
 * Response from sync endpoint.

Returns processing statistics and any new achievements unlocked.
 */
export interface SyncResponse {
  /** Whether sync was successful */
  success?: boolean;
  /** Optional message */
  message?: SyncResponseMessage;
  /** Total records processed */
  recordsProcessed: number;
  /** Number of new records created */
  newRecords: number;
  /** Number of existing records updated */
  updatedRecords: number;
  /** Updated user statistics */
  stats: SyncStatsResponse;
  /** Achievements unlocked during this sync */
  newAchievements?: AchievementUnlockResponse[];
}

/**
 * User statistics after sync operation.
 */
export interface SyncStatsResponse {
  /** Total tokens across all usage */
  totalTokens: number;
  /** Total cost in USD */
  totalCost: number;
  /** Current consecutive days streak */
  currentStreak: number;
  /** Longest streak achieved */
  longestStreak: number;
  /** Total achievements unlocked */
  achievementsUnlocked: number;
}

/**
 * Tool/source usage breakdown.
 */
export interface ToolUsageData {
  /** Source/tool identifier */
  source: string;
  /** Total tokens for this source */
  tokens: number;
  /** Total cost in USD for this source */
  cost: number;
  /** Percentage of total usage (0-100) */
  percentage: number;
  /** Number of days this source was used */
  days_active: number;
}

export type UserComparisonDataResponseName = string | null;

export type UserComparisonDataResponseImage = string | null;

export type UserComparisonDataResponseTokens = { [key: string]: unknown };

export type UserComparisonDataResponseCost = { [key: string]: unknown };

export type UserComparisonDataResponseStreak = { [key: string]: unknown };

export type UserComparisonDataResponseTopModelsItem = { [key: string]: unknown };

export type UserComparisonDataResponseTopSourcesItem = { [key: string]: unknown };

/**
 * User comparison data for compare page.

Includes profile info, stats, and top models/sources.
 */
export interface UserComparisonDataResponse {
  id: string;
  created_at: string;
  updated_at: string;
  username: string;
  name: UserComparisonDataResponseName;
  image: UserComparisonDataResponseImage;
  tokens: UserComparisonDataResponseTokens;
  cost: UserComparisonDataResponseCost;
  streak: UserComparisonDataResponseStreak;
  top_models: UserComparisonDataResponseTopModelsItem[];
  top_sources: UserComparisonDataResponseTopSourcesItem[];
}

/**
 * Display name
 */
export type UserMinimalResponseName = string | null;

/**
 * Profile image URL
 */
export type UserMinimalResponseImage = string | null;

/**
 * Minimal user information for activity feed display.

Avoids circular imports by defining a minimal user schema here.
 */
export interface UserMinimalResponse {
  id: string;
  created_at: string;
  updated_at: string;
  /** Username */
  username: string;
  /** Display name */
  name?: UserMinimalResponseName;
  /** Profile image URL */
  image?: UserMinimalResponseImage;
}

export type UserPublicResponseName = string | null;

export type UserPublicResponseBio = string | null;

export type UserPublicResponseLocation = string | null;

export type UserPublicResponseRegion = string | null;

export type UserPublicResponseWebsiteUrl = string | null;

export type UserPublicResponseImage = string | null;

export type UserPublicResponseMonthlyBadge = string | null;

/**
 * Limited user response for public profiles.

Only includes publicly visible fields.
Used when viewing other users' profiles.
 */
export interface UserPublicResponse {
  id: string;
  created_at: string;
  updated_at: string;
  username: string;
  name: UserPublicResponseName;
  bio: UserPublicResponseBio;
  location: UserPublicResponseLocation;
  region: UserPublicResponseRegion;
  website_url: UserPublicResponseWebsiteUrl;
  is_public: boolean;
  image: UserPublicResponseImage;
  monthly_badge: UserPublicResponseMonthlyBadge;
  monthly_tokens: number;
}

export type UserResponseName = string | null;

export type UserResponseBio = string | null;

export type UserResponseLocation = string | null;

export type UserResponseRegion = string | null;

export type UserResponseWebsiteUrl = string | null;

export type UserResponseImage = string | null;

export type UserResponseMonthlyBadge = string | null;

/**
 * Full user response schema.

Includes all user fields except password_hash.
Used for authenticated requests where user is viewing their own profile.
 */
export interface UserResponse {
  id: string;
  created_at: string;
  updated_at: string;
  email: string;
  email_verified: boolean;
  username: string;
  name: UserResponseName;
  bio: UserResponseBio;
  location: UserResponseLocation;
  region: UserResponseRegion;
  website_url: UserResponseWebsiteUrl;
  is_public: boolean;
  image: UserResponseImage;
  monthly_badge: UserResponseMonthlyBadge;
  monthly_tokens: number;
}

export type UserStatsResponseCacheEfficiency = number | null;

export type UserStatsResponseMonthlyBadge = string | null;

/**
 * User statistics response.

Aggregated usage and achievement statistics.
 */
export interface UserStatsResponse {
  id: string;
  created_at: string;
  updated_at: string;
  username: string;
  total_tokens: number;
  total_cost: number;
  current_streak: number;
  longest_streak: number;
  achievements_unlocked: number;
  unique_days: number;
  cache_efficiency: UserStatsResponseCacheEfficiency;
  monthly_tokens: number;
  monthly_badge: UserStatsResponseMonthlyBadge;
}

export type UserUpdateName = string | null;

export type UserUpdateBio = string | null;

export type UserUpdateLocation = string | null;

export type UserUpdateRegion = string | null;

export type UserUpdateWebsiteUrl = string | null;

export type UserUpdateIsPublic = boolean | null;

export type UserUpdateImage = string | null;

/**
 * Schema for updating user profile.

All fields optional for PATCH operations.
 */
export interface UserUpdate {
  name?: UserUpdateName;
  bio?: UserUpdateBio;
  location?: UserUpdateLocation;
  region?: UserUpdateRegion;
  website_url?: UserUpdateWebsiteUrl;
  is_public?: UserUpdateIsPublic;
  image?: UserUpdateImage;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type OauthCallbackApiV1AuthOauthProviderCallbackGetParams = {
  code?: string | null;
  state?: string | null;
  error?: string | null;
  error_description?: string | null;
};

export type GetUserProfileApiV1UsersUsernameGet200 = UserPublicResponse | UserResponse;

export type GetUserFollowersApiV1UsersUsernameFollowersGetParams = {
  /**
   * @minimum 1
   */
  page?: number;
  /**
   * @minimum 1
   * @maximum 100
   */
  size?: number;
};

export type GetUserFollowingApiV1UsersUsernameFollowingGetParams = {
  /**
   * @minimum 1
   */
  page?: number;
  /**
   * @minimum 1
   * @maximum 100
   */
  size?: number;
};

export type GetUserProjectsApiV1UsersUsernameProjectsGetParams = {
  /**
   * @minimum 0
   */
  skip?: number;
  /**
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
};

export type GetLeaderboardApiV1LeaderboardGetParams = {
  /**
   * Time period (all, month, week)
   * @pattern ^(all|month|week)$
   */
  period?: string;
  /**
   * Sort field (tokens, cost, streak)
   * @pattern ^(tokens|cost|streak)$
   */
  sort_by?: string;
  /**
   * Maximum number of entries to return
   * @minimum 1
   * @maximum 1000
   */
  limit?: number;
  /**
   * Number of entries to skip for pagination
   * @minimum 0
   */
  offset?: number;
};

export type GetUserLeaderboardRankApiV1LeaderboardUsernameGetParams = {
  /**
   * Time period
   * @pattern ^(all|month|week)$
   */
  period?: string;
};

export type GetUserLeaderboardRankApiV1LeaderboardUsernameGet200 = LeaderboardEntryResponse | null;

export type GetFeedApiV1FeedGetParams = {
  /**
   * @minimum 1
   */
  page?: number;
  /**
   * @minimum 1
   * @maximum 100
   */
  size?: number;
};

export type UpdateProjectApiV1ProjectsProjectIdPatchParams = {
  refetch_metadata?: boolean;
};

export type GetUserInsightsApiV1InsightsGetParams = {
  /**
   * Time period for insights (all, month, week)
   * @pattern ^(all|month|week)$
   */
  period?: string;
};

export type GetTrendsApiV1DashboardTrendsGetParams = {
  /**
   * Number of days to include (1-365)
   * @minimum 1
   * @maximum 365
   */
  days?: number;
};
