/**
 * Generated by orval v7.18.0 üç∫
 * Do not edit manually.
 * Burntop API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  ComparisonResponse,
  DashboardModelsResponse,
  DashboardToolsResponse,
  DashboardTrendsResponse,
  FollowResponse,
  FollowStatsResponse,
  GetUserFollowersApiV1UsersUsernameFollowersGetParams,
  GetUserFollowingApiV1UsersUsernameFollowingGetParams,
  GetUserProfileApiV1UsersUsernameGet200,
  HTTPValidationError,
  PageFollowerResponse,
  UserResponse,
  UserStatsResponse,
  UserUpdate,
} from '../generated.schemas';

import { customInstance } from '.././client';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Get user profile by username.

Returns full profile (UserResponse) if viewing own profile,
or limited public profile (UserPublicResponse) if viewing another user's profile.

Args:
    username: Username to retrieve
    user_service: User service instance
    session: Database session for usage record queries
    current_user: Optional authenticated user

Returns:
    UserPublicResponse or UserResponse depending on authorization

Raises:
    NotFoundError: If user not found (404)
 * @summary Get User Profile
 */
export type getUserProfileApiV1UsersUsernameGetResponse200 = {
  data: GetUserProfileApiV1UsersUsernameGet200;
  status: 200;
};

export type getUserProfileApiV1UsersUsernameGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type getUserProfileApiV1UsersUsernameGetResponseSuccess =
  getUserProfileApiV1UsersUsernameGetResponse200 & {
    headers: Headers;
  };
export type getUserProfileApiV1UsersUsernameGetResponseError =
  getUserProfileApiV1UsersUsernameGetResponse422 & {
    headers: Headers;
  };

export type getUserProfileApiV1UsersUsernameGetResponse =
  | getUserProfileApiV1UsersUsernameGetResponseSuccess
  | getUserProfileApiV1UsersUsernameGetResponseError;

export const getGetUserProfileApiV1UsersUsernameGetUrl = (username: string) => {
  return `/api/v1/users/${username}`;
};

export const getUserProfileApiV1UsersUsernameGet = async (
  username: string,
  options?: RequestInit
): Promise<getUserProfileApiV1UsersUsernameGetResponse> => {
  return customInstance<getUserProfileApiV1UsersUsernameGetResponse>(
    getGetUserProfileApiV1UsersUsernameGetUrl(username),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetUserProfileApiV1UsersUsernameGetQueryKey = (username?: string) => {
  return [`/api/v1/users/${username}`] as const;
};

export const getGetUserProfileApiV1UsersUsernameGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserProfileApiV1UsersUsernameGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserProfileApiV1UsersUsernameGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserProfileApiV1UsersUsernameGetQueryKey(username);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserProfileApiV1UsersUsernameGet>>> = ({
    signal,
  }) => getUserProfileApiV1UsersUsernameGet(username, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!username, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserProfileApiV1UsersUsernameGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserProfileApiV1UsersUsernameGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserProfileApiV1UsersUsernameGet>>
>;
export type GetUserProfileApiV1UsersUsernameGetQueryError = HTTPValidationError;

/**
 * @summary Get User Profile
 */

export function useGetUserProfileApiV1UsersUsernameGet<
  TData = Awaited<ReturnType<typeof getUserProfileApiV1UsersUsernameGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserProfileApiV1UsersUsernameGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetUserProfileApiV1UsersUsernameGetQueryOptions(username, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update authenticated user's own profile.

Args:
    profile_update: Profile fields to update (all optional for PATCH)
    user_service: User service instance
    session: Database session for usage record queries
    current_user: Authenticated user

Returns:
    Updated user profile

Raises:
    UnauthorizedError: If not authenticated (401)
 * @summary Update Own Profile
 */
export type updateOwnProfileApiV1UsersMePatchResponse200 = {
  data: UserResponse;
  status: 200;
};

export type updateOwnProfileApiV1UsersMePatchResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type updateOwnProfileApiV1UsersMePatchResponseSuccess =
  updateOwnProfileApiV1UsersMePatchResponse200 & {
    headers: Headers;
  };
export type updateOwnProfileApiV1UsersMePatchResponseError =
  updateOwnProfileApiV1UsersMePatchResponse422 & {
    headers: Headers;
  };

export type updateOwnProfileApiV1UsersMePatchResponse =
  | updateOwnProfileApiV1UsersMePatchResponseSuccess
  | updateOwnProfileApiV1UsersMePatchResponseError;

export const getUpdateOwnProfileApiV1UsersMePatchUrl = () => {
  return `/api/v1/users/me`;
};

export const updateOwnProfileApiV1UsersMePatch = async (
  userUpdate: UserUpdate,
  options?: RequestInit
): Promise<updateOwnProfileApiV1UsersMePatchResponse> => {
  return customInstance<updateOwnProfileApiV1UsersMePatchResponse>(
    getUpdateOwnProfileApiV1UsersMePatchUrl(),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(userUpdate),
    }
  );
};

export const getUpdateOwnProfileApiV1UsersMePatchMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateOwnProfileApiV1UsersMePatch>>,
    TError,
    { data: UserUpdate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateOwnProfileApiV1UsersMePatch>>,
  TError,
  { data: UserUpdate },
  TContext
> => {
  const mutationKey = ['updateOwnProfileApiV1UsersMePatch'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateOwnProfileApiV1UsersMePatch>>,
    { data: UserUpdate }
  > = (props) => {
    const { data } = props ?? {};

    return updateOwnProfileApiV1UsersMePatch(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateOwnProfileApiV1UsersMePatchMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateOwnProfileApiV1UsersMePatch>>
>;
export type UpdateOwnProfileApiV1UsersMePatchMutationBody = UserUpdate;
export type UpdateOwnProfileApiV1UsersMePatchMutationError = HTTPValidationError;

/**
 * @summary Update Own Profile
 */
export const useUpdateOwnProfileApiV1UsersMePatch = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateOwnProfileApiV1UsersMePatch>>,
    TError,
    { data: UserUpdate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateOwnProfileApiV1UsersMePatch>>,
  TError,
  { data: UserUpdate },
  TContext
> => {
  const mutationOptions = getUpdateOwnProfileApiV1UsersMePatchMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Get aggregated statistics for a user.

Returns token usage, cost, streak, and achievement statistics.

Args:
    username: Username to get stats for
    user_service: User service instance

Returns:
    User statistics

Raises:
    NotFoundError: If user not found (404)
 * @summary Get User Stats
 */
export type getUserStatsApiV1UsersUsernameStatsGetResponse200 = {
  data: UserStatsResponse;
  status: 200;
};

export type getUserStatsApiV1UsersUsernameStatsGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type getUserStatsApiV1UsersUsernameStatsGetResponseSuccess =
  getUserStatsApiV1UsersUsernameStatsGetResponse200 & {
    headers: Headers;
  };
export type getUserStatsApiV1UsersUsernameStatsGetResponseError =
  getUserStatsApiV1UsersUsernameStatsGetResponse422 & {
    headers: Headers;
  };

export type getUserStatsApiV1UsersUsernameStatsGetResponse =
  | getUserStatsApiV1UsersUsernameStatsGetResponseSuccess
  | getUserStatsApiV1UsersUsernameStatsGetResponseError;

export const getGetUserStatsApiV1UsersUsernameStatsGetUrl = (username: string) => {
  return `/api/v1/users/${username}/stats`;
};

export const getUserStatsApiV1UsersUsernameStatsGet = async (
  username: string,
  options?: RequestInit
): Promise<getUserStatsApiV1UsersUsernameStatsGetResponse> => {
  return customInstance<getUserStatsApiV1UsersUsernameStatsGetResponse>(
    getGetUserStatsApiV1UsersUsernameStatsGetUrl(username),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetUserStatsApiV1UsersUsernameStatsGetQueryKey = (username?: string) => {
  return [`/api/v1/users/${username}/stats`] as const;
};

export const getGetUserStatsApiV1UsersUsernameStatsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserStatsApiV1UsersUsernameStatsGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserStatsApiV1UsersUsernameStatsGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserStatsApiV1UsersUsernameStatsGetQueryKey(username);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserStatsApiV1UsersUsernameStatsGet>>
  > = ({ signal }) =>
    getUserStatsApiV1UsersUsernameStatsGet(username, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!username, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserStatsApiV1UsersUsernameStatsGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserStatsApiV1UsersUsernameStatsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserStatsApiV1UsersUsernameStatsGet>>
>;
export type GetUserStatsApiV1UsersUsernameStatsGetQueryError = HTTPValidationError;

/**
 * @summary Get User Stats
 */

export function useGetUserStatsApiV1UsersUsernameStatsGet<
  TData = Awaited<ReturnType<typeof getUserStatsApiV1UsersUsernameStatsGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserStatsApiV1UsersUsernameStatsGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetUserStatsApiV1UsersUsernameStatsGetQueryOptions(username, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get tool/source usage breakdown for a user.

Returns public breakdown of tools/sources used by the user.

Args:
    username: Username to get tools for
    user_service: User service instance
    dashboard_service: Dashboard service instance

Returns:
    Tool usage breakdown

Raises:
    NotFoundError: If user not found (404)
 * @summary Get User Tools
 */
export type getUserToolsApiV1UsersUsernameToolsGetResponse200 = {
  data: DashboardToolsResponse;
  status: 200;
};

export type getUserToolsApiV1UsersUsernameToolsGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type getUserToolsApiV1UsersUsernameToolsGetResponseSuccess =
  getUserToolsApiV1UsersUsernameToolsGetResponse200 & {
    headers: Headers;
  };
export type getUserToolsApiV1UsersUsernameToolsGetResponseError =
  getUserToolsApiV1UsersUsernameToolsGetResponse422 & {
    headers: Headers;
  };

export type getUserToolsApiV1UsersUsernameToolsGetResponse =
  | getUserToolsApiV1UsersUsernameToolsGetResponseSuccess
  | getUserToolsApiV1UsersUsernameToolsGetResponseError;

export const getGetUserToolsApiV1UsersUsernameToolsGetUrl = (username: string) => {
  return `/api/v1/users/${username}/tools`;
};

export const getUserToolsApiV1UsersUsernameToolsGet = async (
  username: string,
  options?: RequestInit
): Promise<getUserToolsApiV1UsersUsernameToolsGetResponse> => {
  return customInstance<getUserToolsApiV1UsersUsernameToolsGetResponse>(
    getGetUserToolsApiV1UsersUsernameToolsGetUrl(username),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetUserToolsApiV1UsersUsernameToolsGetQueryKey = (username?: string) => {
  return [`/api/v1/users/${username}/tools`] as const;
};

export const getGetUserToolsApiV1UsersUsernameToolsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserToolsApiV1UsersUsernameToolsGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserToolsApiV1UsersUsernameToolsGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserToolsApiV1UsersUsernameToolsGetQueryKey(username);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserToolsApiV1UsersUsernameToolsGet>>
  > = ({ signal }) =>
    getUserToolsApiV1UsersUsernameToolsGet(username, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!username, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserToolsApiV1UsersUsernameToolsGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserToolsApiV1UsersUsernameToolsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserToolsApiV1UsersUsernameToolsGet>>
>;
export type GetUserToolsApiV1UsersUsernameToolsGetQueryError = HTTPValidationError;

/**
 * @summary Get User Tools
 */

export function useGetUserToolsApiV1UsersUsernameToolsGet<
  TData = Awaited<ReturnType<typeof getUserToolsApiV1UsersUsernameToolsGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserToolsApiV1UsersUsernameToolsGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetUserToolsApiV1UsersUsernameToolsGetQueryOptions(username, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get AI model usage breakdown for a user.

Returns public breakdown of AI models used by the user.

Args:
    username: Username to get models for
    user_service: User service instance
    dashboard_service: Dashboard service instance

Returns:
    Model usage breakdown

Raises:
    NotFoundError: If user not found (404)
 * @summary Get User Models
 */
export type getUserModelsApiV1UsersUsernameModelsGetResponse200 = {
  data: DashboardModelsResponse;
  status: 200;
};

export type getUserModelsApiV1UsersUsernameModelsGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type getUserModelsApiV1UsersUsernameModelsGetResponseSuccess =
  getUserModelsApiV1UsersUsernameModelsGetResponse200 & {
    headers: Headers;
  };
export type getUserModelsApiV1UsersUsernameModelsGetResponseError =
  getUserModelsApiV1UsersUsernameModelsGetResponse422 & {
    headers: Headers;
  };

export type getUserModelsApiV1UsersUsernameModelsGetResponse =
  | getUserModelsApiV1UsersUsernameModelsGetResponseSuccess
  | getUserModelsApiV1UsersUsernameModelsGetResponseError;

export const getGetUserModelsApiV1UsersUsernameModelsGetUrl = (username: string) => {
  return `/api/v1/users/${username}/models`;
};

export const getUserModelsApiV1UsersUsernameModelsGet = async (
  username: string,
  options?: RequestInit
): Promise<getUserModelsApiV1UsersUsernameModelsGetResponse> => {
  return customInstance<getUserModelsApiV1UsersUsernameModelsGetResponse>(
    getGetUserModelsApiV1UsersUsernameModelsGetUrl(username),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetUserModelsApiV1UsersUsernameModelsGetQueryKey = (username?: string) => {
  return [`/api/v1/users/${username}/models`] as const;
};

export const getGetUserModelsApiV1UsersUsernameModelsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserModelsApiV1UsersUsernameModelsGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserModelsApiV1UsersUsernameModelsGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserModelsApiV1UsersUsernameModelsGetQueryKey(username);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserModelsApiV1UsersUsernameModelsGet>>
  > = ({ signal }) =>
    getUserModelsApiV1UsersUsernameModelsGet(username, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!username, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserModelsApiV1UsersUsernameModelsGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserModelsApiV1UsersUsernameModelsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserModelsApiV1UsersUsernameModelsGet>>
>;
export type GetUserModelsApiV1UsersUsernameModelsGetQueryError = HTTPValidationError;

/**
 * @summary Get User Models
 */

export function useGetUserModelsApiV1UsersUsernameModelsGet<
  TData = Awaited<ReturnType<typeof getUserModelsApiV1UsersUsernameModelsGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserModelsApiV1UsersUsernameModelsGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetUserModelsApiV1UsersUsernameModelsGetQueryOptions(username, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get usage trends over time for a user.
 *
 * Returns daily usage data points for charting over a specified time period.
 *
 * Args:
 *     username: Username to get trends for
 *     days: Number of days to include (default 365, max 365)
 *
 * Returns:
 *     Daily usage trends with date, tokens, and cost data
 *
 * Raises:
 *     NotFoundError: If user not found (404)
 * @summary Get User Trends
 */
export interface GetUserTrendsApiV1UsersUsernameTrendsGetParams {
  days?: number;
}

export type getUserTrendsApiV1UsersUsernameTrendsGetResponse200 = {
  data: DashboardTrendsResponse;
  status: 200;
};

export type getUserTrendsApiV1UsersUsernameTrendsGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type getUserTrendsApiV1UsersUsernameTrendsGetResponseSuccess =
  getUserTrendsApiV1UsersUsernameTrendsGetResponse200 & {
    headers: Headers;
  };
export type getUserTrendsApiV1UsersUsernameTrendsGetResponseError =
  getUserTrendsApiV1UsersUsernameTrendsGetResponse422 & {
    headers: Headers;
  };

export type getUserTrendsApiV1UsersUsernameTrendsGetResponse =
  | getUserTrendsApiV1UsersUsernameTrendsGetResponseSuccess
  | getUserTrendsApiV1UsersUsernameTrendsGetResponseError;

export const getGetUserTrendsApiV1UsersUsernameTrendsGetUrl = (
  username: string,
  params?: GetUserTrendsApiV1UsersUsernameTrendsGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/users/${username}/trends?${stringifiedParams}`
    : `/api/v1/users/${username}/trends`;
};

export const getUserTrendsApiV1UsersUsernameTrendsGet = async (
  username: string,
  params?: GetUserTrendsApiV1UsersUsernameTrendsGetParams,
  options?: RequestInit
): Promise<getUserTrendsApiV1UsersUsernameTrendsGetResponse> => {
  return customInstance<getUserTrendsApiV1UsersUsernameTrendsGetResponse>(
    getGetUserTrendsApiV1UsersUsernameTrendsGetUrl(username, params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetUserTrendsApiV1UsersUsernameTrendsGetQueryKey = (
  username?: string,
  params?: GetUserTrendsApiV1UsersUsernameTrendsGetParams
) => {
  return [`/api/v1/users/${username}/trends`, ...(params ? [params] : [])] as const;
};

export const getGetUserTrendsApiV1UsersUsernameTrendsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserTrendsApiV1UsersUsernameTrendsGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  params?: GetUserTrendsApiV1UsersUsernameTrendsGetParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserTrendsApiV1UsersUsernameTrendsGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserTrendsApiV1UsersUsernameTrendsGetQueryKey(username, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserTrendsApiV1UsersUsernameTrendsGet>>
  > = ({ signal }) =>
    getUserTrendsApiV1UsersUsernameTrendsGet(username, params, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!username, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserTrendsApiV1UsersUsernameTrendsGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserTrendsApiV1UsersUsernameTrendsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserTrendsApiV1UsersUsernameTrendsGet>>
>;
export type GetUserTrendsApiV1UsersUsernameTrendsGetQueryError = HTTPValidationError;

/**
 * @summary Get User Trends
 */

export function useGetUserTrendsApiV1UsersUsernameTrendsGet<
  TData = Awaited<ReturnType<typeof getUserTrendsApiV1UsersUsernameTrendsGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  params?: GetUserTrendsApiV1UsersUsernameTrendsGetParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserTrendsApiV1UsersUsernameTrendsGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetUserTrendsApiV1UsersUsernameTrendsGetQueryOptions(
    username,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get follow statistics for a user.

Returns follower and following counts, plus relationship status for authenticated users.

Args:
    username: Username to get follow stats for
    user_service: User service instance
    follow_service: Follow service instance
    current_user: Optional authenticated user

Returns:
    Follow statistics including follower/following counts and relationship status

Raises:
    NotFoundError: If user not found (404)
 * @summary Get User Follow Stats
 */
export type getUserFollowStatsApiV1UsersUsernameFollowStatsGetResponse200 = {
  data: FollowStatsResponse;
  status: 200;
};

export type getUserFollowStatsApiV1UsersUsernameFollowStatsGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type getUserFollowStatsApiV1UsersUsernameFollowStatsGetResponseSuccess =
  getUserFollowStatsApiV1UsersUsernameFollowStatsGetResponse200 & {
    headers: Headers;
  };
export type getUserFollowStatsApiV1UsersUsernameFollowStatsGetResponseError =
  getUserFollowStatsApiV1UsersUsernameFollowStatsGetResponse422 & {
    headers: Headers;
  };

export type getUserFollowStatsApiV1UsersUsernameFollowStatsGetResponse =
  | getUserFollowStatsApiV1UsersUsernameFollowStatsGetResponseSuccess
  | getUserFollowStatsApiV1UsersUsernameFollowStatsGetResponseError;

export const getGetUserFollowStatsApiV1UsersUsernameFollowStatsGetUrl = (username: string) => {
  return `/api/v1/users/${username}/follow-stats`;
};

export const getUserFollowStatsApiV1UsersUsernameFollowStatsGet = async (
  username: string,
  options?: RequestInit
): Promise<getUserFollowStatsApiV1UsersUsernameFollowStatsGetResponse> => {
  return customInstance<getUserFollowStatsApiV1UsersUsernameFollowStatsGetResponse>(
    getGetUserFollowStatsApiV1UsersUsernameFollowStatsGetUrl(username),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetUserFollowStatsApiV1UsersUsernameFollowStatsGetQueryKey = (
  username?: string
) => {
  return [`/api/v1/users/${username}/follow-stats`] as const;
};

export const getGetUserFollowStatsApiV1UsersUsernameFollowStatsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserFollowStatsApiV1UsersUsernameFollowStatsGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserFollowStatsApiV1UsersUsernameFollowStatsGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetUserFollowStatsApiV1UsersUsernameFollowStatsGetQueryKey(username);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserFollowStatsApiV1UsersUsernameFollowStatsGet>>
  > = ({ signal }) =>
    getUserFollowStatsApiV1UsersUsernameFollowStatsGet(username, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!username, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserFollowStatsApiV1UsersUsernameFollowStatsGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserFollowStatsApiV1UsersUsernameFollowStatsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserFollowStatsApiV1UsersUsernameFollowStatsGet>>
>;
export type GetUserFollowStatsApiV1UsersUsernameFollowStatsGetQueryError = HTTPValidationError;

/**
 * @summary Get User Follow Stats
 */

export function useGetUserFollowStatsApiV1UsersUsernameFollowStatsGet<
  TData = Awaited<ReturnType<typeof getUserFollowStatsApiV1UsersUsernameFollowStatsGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserFollowStatsApiV1UsersUsernameFollowStatsGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetUserFollowStatsApiV1UsersUsernameFollowStatsGetQueryOptions(
    username,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Follow a user.

Creates a follow relationship between the authenticated user and the target user.

Args:
    username: Username to follow
    user_service: User service instance
    follow_service: Follow service instance
    current_user: Authenticated user

Returns:
    Follow relationship details

Raises:
    UnauthorizedError: If not authenticated (401)
    NotFoundError: If user not found (404)
    BadRequestError: If user tries to follow themselves (400)
    ConflictError: If already following this user (409)
 * @summary Follow User
 */
export type followUserApiV1UsersUsernameFollowPostResponse201 = {
  data: FollowResponse;
  status: 201;
};

export type followUserApiV1UsersUsernameFollowPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type followUserApiV1UsersUsernameFollowPostResponseSuccess =
  followUserApiV1UsersUsernameFollowPostResponse201 & {
    headers: Headers;
  };
export type followUserApiV1UsersUsernameFollowPostResponseError =
  followUserApiV1UsersUsernameFollowPostResponse422 & {
    headers: Headers;
  };

export type followUserApiV1UsersUsernameFollowPostResponse =
  | followUserApiV1UsersUsernameFollowPostResponseSuccess
  | followUserApiV1UsersUsernameFollowPostResponseError;

export const getFollowUserApiV1UsersUsernameFollowPostUrl = (username: string) => {
  return `/api/v1/users/${username}/follow`;
};

export const followUserApiV1UsersUsernameFollowPost = async (
  username: string,
  options?: RequestInit
): Promise<followUserApiV1UsersUsernameFollowPostResponse> => {
  return customInstance<followUserApiV1UsersUsernameFollowPostResponse>(
    getFollowUserApiV1UsersUsernameFollowPostUrl(username),
    {
      ...options,
      method: 'POST',
    }
  );
};

export const getFollowUserApiV1UsersUsernameFollowPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof followUserApiV1UsersUsernameFollowPost>>,
    TError,
    { username: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof followUserApiV1UsersUsernameFollowPost>>,
  TError,
  { username: string },
  TContext
> => {
  const mutationKey = ['followUserApiV1UsersUsernameFollowPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof followUserApiV1UsersUsernameFollowPost>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return followUserApiV1UsersUsernameFollowPost(username, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type FollowUserApiV1UsersUsernameFollowPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof followUserApiV1UsersUsernameFollowPost>>
>;

export type FollowUserApiV1UsersUsernameFollowPostMutationError = HTTPValidationError;

/**
 * @summary Follow User
 */
export const useFollowUserApiV1UsersUsernameFollowPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof followUserApiV1UsersUsernameFollowPost>>,
    TError,
    { username: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof followUserApiV1UsersUsernameFollowPost>>,
  TError,
  { username: string },
  TContext
> => {
  const mutationOptions = getFollowUserApiV1UsersUsernameFollowPostMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Unfollow a user.

Removes the follow relationship between the authenticated user and the target user.

Args:
    username: Username to unfollow
    user_service: User service instance
    follow_service: Follow service instance
    current_user: Authenticated user

Returns:
    None (204 No Content)

Raises:
    UnauthorizedError: If not authenticated (401)
    NotFoundError: If user not found (404)
    BadRequestError: If user tries to unfollow themselves (400)
 * @summary Unfollow User
 */
export type unfollowUserApiV1UsersUsernameFollowDeleteResponse204 = {
  data: void;
  status: 204;
};

export type unfollowUserApiV1UsersUsernameFollowDeleteResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type unfollowUserApiV1UsersUsernameFollowDeleteResponseSuccess =
  unfollowUserApiV1UsersUsernameFollowDeleteResponse204 & {
    headers: Headers;
  };
export type unfollowUserApiV1UsersUsernameFollowDeleteResponseError =
  unfollowUserApiV1UsersUsernameFollowDeleteResponse422 & {
    headers: Headers;
  };

export type unfollowUserApiV1UsersUsernameFollowDeleteResponse =
  | unfollowUserApiV1UsersUsernameFollowDeleteResponseSuccess
  | unfollowUserApiV1UsersUsernameFollowDeleteResponseError;

export const getUnfollowUserApiV1UsersUsernameFollowDeleteUrl = (username: string) => {
  return `/api/v1/users/${username}/follow`;
};

export const unfollowUserApiV1UsersUsernameFollowDelete = async (
  username: string,
  options?: RequestInit
): Promise<unfollowUserApiV1UsersUsernameFollowDeleteResponse> => {
  return customInstance<unfollowUserApiV1UsersUsernameFollowDeleteResponse>(
    getUnfollowUserApiV1UsersUsernameFollowDeleteUrl(username),
    {
      ...options,
      method: 'DELETE',
    }
  );
};

export const getUnfollowUserApiV1UsersUsernameFollowDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof unfollowUserApiV1UsersUsernameFollowDelete>>,
    TError,
    { username: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof unfollowUserApiV1UsersUsernameFollowDelete>>,
  TError,
  { username: string },
  TContext
> => {
  const mutationKey = ['unfollowUserApiV1UsersUsernameFollowDelete'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof unfollowUserApiV1UsersUsernameFollowDelete>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return unfollowUserApiV1UsersUsernameFollowDelete(username, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UnfollowUserApiV1UsersUsernameFollowDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof unfollowUserApiV1UsersUsernameFollowDelete>>
>;

export type UnfollowUserApiV1UsersUsernameFollowDeleteMutationError = HTTPValidationError;

/**
 * @summary Unfollow User
 */
export const useUnfollowUserApiV1UsersUsernameFollowDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof unfollowUserApiV1UsersUsernameFollowDelete>>,
    TError,
    { username: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof unfollowUserApiV1UsersUsernameFollowDelete>>,
  TError,
  { username: string },
  TContext
> => {
  const mutationOptions = getUnfollowUserApiV1UsersUsernameFollowDeleteMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Get list of users following this user.

Args:
    username: Username to get followers for
    user_service: User service instance
    follow_service: Follow service instance
    params: Pagination parameters

Returns:
    Paginated list of follower users

Raises:
    NotFoundError: If user not found (404)
 * @summary Get User Followers
 */
export type getUserFollowersApiV1UsersUsernameFollowersGetResponse200 = {
  data: PageFollowerResponse;
  status: 200;
};

export type getUserFollowersApiV1UsersUsernameFollowersGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type getUserFollowersApiV1UsersUsernameFollowersGetResponseSuccess =
  getUserFollowersApiV1UsersUsernameFollowersGetResponse200 & {
    headers: Headers;
  };
export type getUserFollowersApiV1UsersUsernameFollowersGetResponseError =
  getUserFollowersApiV1UsersUsernameFollowersGetResponse422 & {
    headers: Headers;
  };

export type getUserFollowersApiV1UsersUsernameFollowersGetResponse =
  | getUserFollowersApiV1UsersUsernameFollowersGetResponseSuccess
  | getUserFollowersApiV1UsersUsernameFollowersGetResponseError;

export const getGetUserFollowersApiV1UsersUsernameFollowersGetUrl = (
  username: string,
  params?: GetUserFollowersApiV1UsersUsernameFollowersGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/users/${username}/followers?${stringifiedParams}`
    : `/api/v1/users/${username}/followers`;
};

export const getUserFollowersApiV1UsersUsernameFollowersGet = async (
  username: string,
  params?: GetUserFollowersApiV1UsersUsernameFollowersGetParams,
  options?: RequestInit
): Promise<getUserFollowersApiV1UsersUsernameFollowersGetResponse> => {
  return customInstance<getUserFollowersApiV1UsersUsernameFollowersGetResponse>(
    getGetUserFollowersApiV1UsersUsernameFollowersGetUrl(username, params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetUserFollowersApiV1UsersUsernameFollowersGetQueryKey = (
  username?: string,
  params?: GetUserFollowersApiV1UsersUsernameFollowersGetParams
) => {
  return [`/api/v1/users/${username}/followers`, ...(params ? [params] : [])] as const;
};

export const getGetUserFollowersApiV1UsersUsernameFollowersGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserFollowersApiV1UsersUsernameFollowersGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  params?: GetUserFollowersApiV1UsersUsernameFollowersGetParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserFollowersApiV1UsersUsernameFollowersGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetUserFollowersApiV1UsersUsernameFollowersGetQueryKey(username, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserFollowersApiV1UsersUsernameFollowersGet>>
  > = ({ signal }) =>
    getUserFollowersApiV1UsersUsernameFollowersGet(username, params, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!username, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserFollowersApiV1UsersUsernameFollowersGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserFollowersApiV1UsersUsernameFollowersGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserFollowersApiV1UsersUsernameFollowersGet>>
>;
export type GetUserFollowersApiV1UsersUsernameFollowersGetQueryError = HTTPValidationError;

/**
 * @summary Get User Followers
 */

export function useGetUserFollowersApiV1UsersUsernameFollowersGet<
  TData = Awaited<ReturnType<typeof getUserFollowersApiV1UsersUsernameFollowersGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  params?: GetUserFollowersApiV1UsersUsernameFollowersGetParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserFollowersApiV1UsersUsernameFollowersGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetUserFollowersApiV1UsersUsernameFollowersGetQueryOptions(
    username,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get list of users this user is following.

Args:
    username: Username to get following list for
    user_service: User service instance
    follow_service: Follow service instance
    params: Pagination parameters

Returns:
    Paginated list of following users

Raises:
    NotFoundError: If user not found (404)
 * @summary Get User Following
 */
export type getUserFollowingApiV1UsersUsernameFollowingGetResponse200 = {
  data: PageFollowerResponse;
  status: 200;
};

export type getUserFollowingApiV1UsersUsernameFollowingGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type getUserFollowingApiV1UsersUsernameFollowingGetResponseSuccess =
  getUserFollowingApiV1UsersUsernameFollowingGetResponse200 & {
    headers: Headers;
  };
export type getUserFollowingApiV1UsersUsernameFollowingGetResponseError =
  getUserFollowingApiV1UsersUsernameFollowingGetResponse422 & {
    headers: Headers;
  };

export type getUserFollowingApiV1UsersUsernameFollowingGetResponse =
  | getUserFollowingApiV1UsersUsernameFollowingGetResponseSuccess
  | getUserFollowingApiV1UsersUsernameFollowingGetResponseError;

export const getGetUserFollowingApiV1UsersUsernameFollowingGetUrl = (
  username: string,
  params?: GetUserFollowingApiV1UsersUsernameFollowingGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/users/${username}/following?${stringifiedParams}`
    : `/api/v1/users/${username}/following`;
};

export const getUserFollowingApiV1UsersUsernameFollowingGet = async (
  username: string,
  params?: GetUserFollowingApiV1UsersUsernameFollowingGetParams,
  options?: RequestInit
): Promise<getUserFollowingApiV1UsersUsernameFollowingGetResponse> => {
  return customInstance<getUserFollowingApiV1UsersUsernameFollowingGetResponse>(
    getGetUserFollowingApiV1UsersUsernameFollowingGetUrl(username, params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetUserFollowingApiV1UsersUsernameFollowingGetQueryKey = (
  username?: string,
  params?: GetUserFollowingApiV1UsersUsernameFollowingGetParams
) => {
  return [`/api/v1/users/${username}/following`, ...(params ? [params] : [])] as const;
};

export const getGetUserFollowingApiV1UsersUsernameFollowingGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserFollowingApiV1UsersUsernameFollowingGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  params?: GetUserFollowingApiV1UsersUsernameFollowingGetParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserFollowingApiV1UsersUsernameFollowingGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetUserFollowingApiV1UsersUsernameFollowingGetQueryKey(username, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserFollowingApiV1UsersUsernameFollowingGet>>
  > = ({ signal }) =>
    getUserFollowingApiV1UsersUsernameFollowingGet(username, params, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!username, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserFollowingApiV1UsersUsernameFollowingGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserFollowingApiV1UsersUsernameFollowingGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserFollowingApiV1UsersUsernameFollowingGet>>
>;
export type GetUserFollowingApiV1UsersUsernameFollowingGetQueryError = HTTPValidationError;

/**
 * @summary Get User Following
 */

export function useGetUserFollowingApiV1UsersUsernameFollowingGet<
  TData = Awaited<ReturnType<typeof getUserFollowingApiV1UsersUsernameFollowingGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  params?: GetUserFollowingApiV1UsersUsernameFollowingGetParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserFollowingApiV1UsersUsernameFollowingGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetUserFollowingApiV1UsersUsernameFollowingGetQueryOptions(
    username,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Compare two users' statistics and achievements.

Both users must have public profiles.

Args:
    username: First username
    other_username: Second username
    user_service: User service instance

Returns:
    ComparisonResponse with data for both users

Raises:
    NotFoundError: If either user not found or has private profile (404)
 * @summary Compare Users
 */
export type compareUsersApiV1UsersUsernameCompareOtherUsernameGetResponse200 = {
  data: ComparisonResponse;
  status: 200;
};

export type compareUsersApiV1UsersUsernameCompareOtherUsernameGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type compareUsersApiV1UsersUsernameCompareOtherUsernameGetResponseSuccess =
  compareUsersApiV1UsersUsernameCompareOtherUsernameGetResponse200 & {
    headers: Headers;
  };
export type compareUsersApiV1UsersUsernameCompareOtherUsernameGetResponseError =
  compareUsersApiV1UsersUsernameCompareOtherUsernameGetResponse422 & {
    headers: Headers;
  };

export type compareUsersApiV1UsersUsernameCompareOtherUsernameGetResponse =
  | compareUsersApiV1UsersUsernameCompareOtherUsernameGetResponseSuccess
  | compareUsersApiV1UsersUsernameCompareOtherUsernameGetResponseError;

export const getCompareUsersApiV1UsersUsernameCompareOtherUsernameGetUrl = (
  username: string,
  otherUsername: string
) => {
  return `/api/v1/users/${username}/compare/${otherUsername}`;
};

export const compareUsersApiV1UsersUsernameCompareOtherUsernameGet = async (
  username: string,
  otherUsername: string,
  options?: RequestInit
): Promise<compareUsersApiV1UsersUsernameCompareOtherUsernameGetResponse> => {
  return customInstance<compareUsersApiV1UsersUsernameCompareOtherUsernameGetResponse>(
    getCompareUsersApiV1UsersUsernameCompareOtherUsernameGetUrl(username, otherUsername),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getCompareUsersApiV1UsersUsernameCompareOtherUsernameGetQueryKey = (
  username?: string,
  otherUsername?: string
) => {
  return [`/api/v1/users/${username}/compare/${otherUsername}`] as const;
};

export const getCompareUsersApiV1UsersUsernameCompareOtherUsernameGetQueryOptions = <
  TData = Awaited<ReturnType<typeof compareUsersApiV1UsersUsernameCompareOtherUsernameGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  otherUsername: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof compareUsersApiV1UsersUsernameCompareOtherUsernameGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getCompareUsersApiV1UsersUsernameCompareOtherUsernameGetQueryKey(username, otherUsername);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof compareUsersApiV1UsersUsernameCompareOtherUsernameGet>>
  > = ({ signal }) =>
    compareUsersApiV1UsersUsernameCompareOtherUsernameGet(username, otherUsername, {
      signal,
      ...requestOptions,
    });

  return {
    queryKey,
    queryFn,
    enabled: !!(username && otherUsername),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof compareUsersApiV1UsersUsernameCompareOtherUsernameGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type CompareUsersApiV1UsersUsernameCompareOtherUsernameGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof compareUsersApiV1UsersUsernameCompareOtherUsernameGet>>
>;
export type CompareUsersApiV1UsersUsernameCompareOtherUsernameGetQueryError = HTTPValidationError;

/**
 * @summary Compare Users
 */

export function useCompareUsersApiV1UsersUsernameCompareOtherUsernameGet<
  TData = Awaited<ReturnType<typeof compareUsersApiV1UsersUsernameCompareOtherUsernameGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  otherUsername: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof compareUsersApiV1UsersUsernameCompareOtherUsernameGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getCompareUsersApiV1UsersUsernameCompareOtherUsernameGetQueryOptions(
    username,
    otherUsername,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}
