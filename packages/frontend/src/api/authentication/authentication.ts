/**
 * Generated by orval v7.18.0 üç∫
 * Do not edit manually.
 * Burntop API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  DeviceTokenExchangeRequest,
  HTTPValidationError,
  LoginRequest,
  OauthCallbackApiV1AuthOauthProviderCallbackGetParams,
  RegisterRequest,
  SessionResponse,
  SessionUserResponse,
} from '../generated.schemas';

import { customInstance } from '.././client';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Register a new user with email and password. Returns a session token for authentication.
 * @summary Register a new user
 */
export type registerApiV1AuthRegisterPostResponse201 = {
  data: SessionResponse;
  status: 201;
};

export type registerApiV1AuthRegisterPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type registerApiV1AuthRegisterPostResponseSuccess =
  registerApiV1AuthRegisterPostResponse201 & {
    headers: Headers;
  };
export type registerApiV1AuthRegisterPostResponseError =
  registerApiV1AuthRegisterPostResponse422 & {
    headers: Headers;
  };

export type registerApiV1AuthRegisterPostResponse =
  | registerApiV1AuthRegisterPostResponseSuccess
  | registerApiV1AuthRegisterPostResponseError;

export const getRegisterApiV1AuthRegisterPostUrl = () => {
  return `/api/v1/auth/register`;
};

export const registerApiV1AuthRegisterPost = async (
  registerRequest: RegisterRequest,
  options?: RequestInit
): Promise<registerApiV1AuthRegisterPostResponse> => {
  return customInstance<registerApiV1AuthRegisterPostResponse>(
    getRegisterApiV1AuthRegisterPostUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(registerRequest),
    }
  );
};

export const getRegisterApiV1AuthRegisterPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>,
    TError,
    { data: RegisterRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>,
  TError,
  { data: RegisterRequest },
  TContext
> => {
  const mutationKey = ['registerApiV1AuthRegisterPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>,
    { data: RegisterRequest }
  > = (props) => {
    const { data } = props ?? {};

    return registerApiV1AuthRegisterPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RegisterApiV1AuthRegisterPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>
>;
export type RegisterApiV1AuthRegisterPostMutationBody = RegisterRequest;
export type RegisterApiV1AuthRegisterPostMutationError = HTTPValidationError;

/**
 * @summary Register a new user
 */
export const useRegisterApiV1AuthRegisterPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>,
    TError,
    { data: RegisterRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>,
  TError,
  { data: RegisterRequest },
  TContext
> => {
  const mutationOptions = getRegisterApiV1AuthRegisterPostMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Authenticate with email and password. Returns a session token.
 * @summary Login with email and password
 */
export type loginApiV1AuthLoginPostResponse200 = {
  data: SessionResponse;
  status: 200;
};

export type loginApiV1AuthLoginPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type loginApiV1AuthLoginPostResponseSuccess = loginApiV1AuthLoginPostResponse200 & {
  headers: Headers;
};
export type loginApiV1AuthLoginPostResponseError = loginApiV1AuthLoginPostResponse422 & {
  headers: Headers;
};

export type loginApiV1AuthLoginPostResponse =
  | loginApiV1AuthLoginPostResponseSuccess
  | loginApiV1AuthLoginPostResponseError;

export const getLoginApiV1AuthLoginPostUrl = () => {
  return `/api/v1/auth/login`;
};

export const loginApiV1AuthLoginPost = async (
  loginRequest: LoginRequest,
  options?: RequestInit
): Promise<loginApiV1AuthLoginPostResponse> => {
  return customInstance<loginApiV1AuthLoginPostResponse>(getLoginApiV1AuthLoginPostUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(loginRequest),
  });
};

export const getLoginApiV1AuthLoginPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>,
    TError,
    { data: LoginRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>,
  TError,
  { data: LoginRequest },
  TContext
> => {
  const mutationKey = ['loginApiV1AuthLoginPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>,
    { data: LoginRequest }
  > = (props) => {
    const { data } = props ?? {};

    return loginApiV1AuthLoginPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LoginApiV1AuthLoginPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>
>;
export type LoginApiV1AuthLoginPostMutationBody = LoginRequest;
export type LoginApiV1AuthLoginPostMutationError = HTTPValidationError;

/**
 * @summary Login with email and password
 */
export const useLoginApiV1AuthLoginPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>,
    TError,
    { data: LoginRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>,
  TError,
  { data: LoginRequest },
  TContext
> => {
  const mutationOptions = getLoginApiV1AuthLoginPostMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Invalidate the current session token. Requires authentication.
 * @summary Logout current user
 */
export type logoutApiV1AuthLogoutPostResponse204 = {
  data: void;
  status: 204;
};

export type logoutApiV1AuthLogoutPostResponseSuccess = logoutApiV1AuthLogoutPostResponse204 & {
  headers: Headers;
};
export type logoutApiV1AuthLogoutPostResponse = logoutApiV1AuthLogoutPostResponseSuccess;

export const getLogoutApiV1AuthLogoutPostUrl = () => {
  return `/api/v1/auth/logout`;
};

export const logoutApiV1AuthLogoutPost = async (
  options?: RequestInit
): Promise<logoutApiV1AuthLogoutPostResponse> => {
  return customInstance<logoutApiV1AuthLogoutPostResponse>(getLogoutApiV1AuthLogoutPostUrl(), {
    ...options,
    method: 'POST',
  });
};

export const getLogoutApiV1AuthLogoutPostMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logoutApiV1AuthLogoutPost>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof logoutApiV1AuthLogoutPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['logoutApiV1AuthLogoutPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof logoutApiV1AuthLogoutPost>>,
    void
  > = () => {
    return logoutApiV1AuthLogoutPost(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LogoutApiV1AuthLogoutPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof logoutApiV1AuthLogoutPost>>
>;

export type LogoutApiV1AuthLogoutPostMutationError = unknown;

/**
 * @summary Logout current user
 */
export const useLogoutApiV1AuthLogoutPost = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logoutApiV1AuthLogoutPost>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof logoutApiV1AuthLogoutPost>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getLogoutApiV1AuthLogoutPostMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Get the currently authenticated user's information. Requires authentication.
 * @summary Get current user
 */
export type getMeApiV1AuthMeGetResponse200 = {
  data: SessionUserResponse;
  status: 200;
};

export type getMeApiV1AuthMeGetResponseSuccess = getMeApiV1AuthMeGetResponse200 & {
  headers: Headers;
};
export type getMeApiV1AuthMeGetResponse = getMeApiV1AuthMeGetResponseSuccess;

export const getGetMeApiV1AuthMeGetUrl = () => {
  return `/api/v1/auth/me`;
};

export const getMeApiV1AuthMeGet = async (
  options?: RequestInit
): Promise<getMeApiV1AuthMeGetResponse> => {
  return customInstance<getMeApiV1AuthMeGetResponse>(getGetMeApiV1AuthMeGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getGetMeApiV1AuthMeGetQueryKey = () => {
  return [`/api/v1/auth/me`] as const;
};

export const getGetMeApiV1AuthMeGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getMeApiV1AuthMeGet>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getMeApiV1AuthMeGet>>, TError, TData>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMeApiV1AuthMeGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMeApiV1AuthMeGet>>> = ({ signal }) =>
    getMeApiV1AuthMeGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMeApiV1AuthMeGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetMeApiV1AuthMeGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMeApiV1AuthMeGet>>
>;
export type GetMeApiV1AuthMeGetQueryError = unknown;

/**
 * @summary Get current user
 */

export function useGetMeApiV1AuthMeGet<
  TData = Awaited<ReturnType<typeof getMeApiV1AuthMeGet>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getMeApiV1AuthMeGet>>, TError, TData>;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetMeApiV1AuthMeGetQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Redirect to OAuth provider for authentication. Supports 'github'.
 * @summary Initiate OAuth flow
 */
export type oauthAuthorizeApiV1AuthOauthProviderGetResponse302 = {
  data: unknown;
  status: 302;
};

export type oauthAuthorizeApiV1AuthOauthProviderGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};
export type oauthAuthorizeApiV1AuthOauthProviderGetResponseError = (
  | oauthAuthorizeApiV1AuthOauthProviderGetResponse302
  | oauthAuthorizeApiV1AuthOauthProviderGetResponse422
) & {
  headers: Headers;
};

export type oauthAuthorizeApiV1AuthOauthProviderGetResponse =
  oauthAuthorizeApiV1AuthOauthProviderGetResponseError;

export const getOauthAuthorizeApiV1AuthOauthProviderGetUrl = (provider: string) => {
  return `/api/v1/auth/oauth/${provider}`;
};

export const oauthAuthorizeApiV1AuthOauthProviderGet = async (
  provider: string,
  options?: RequestInit
): Promise<oauthAuthorizeApiV1AuthOauthProviderGetResponse> => {
  return customInstance<oauthAuthorizeApiV1AuthOauthProviderGetResponse>(
    getOauthAuthorizeApiV1AuthOauthProviderGetUrl(provider),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getOauthAuthorizeApiV1AuthOauthProviderGetQueryKey = (provider?: string) => {
  return [`/api/v1/auth/oauth/${provider}`] as const;
};

export const getOauthAuthorizeApiV1AuthOauthProviderGetQueryOptions = <
  TData = Awaited<ReturnType<typeof oauthAuthorizeApiV1AuthOauthProviderGet>>,
  TError = unknown | HTTPValidationError,
>(
  provider: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof oauthAuthorizeApiV1AuthOauthProviderGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOauthAuthorizeApiV1AuthOauthProviderGetQueryKey(provider);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof oauthAuthorizeApiV1AuthOauthProviderGet>>
  > = ({ signal }) =>
    oauthAuthorizeApiV1AuthOauthProviderGet(provider, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!provider, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof oauthAuthorizeApiV1AuthOauthProviderGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type OauthAuthorizeApiV1AuthOauthProviderGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof oauthAuthorizeApiV1AuthOauthProviderGet>>
>;
export type OauthAuthorizeApiV1AuthOauthProviderGetQueryError = unknown | HTTPValidationError;

/**
 * @summary Initiate OAuth flow
 */

export function useOauthAuthorizeApiV1AuthOauthProviderGet<
  TData = Awaited<ReturnType<typeof oauthAuthorizeApiV1AuthOauthProviderGet>>,
  TError = unknown | HTTPValidationError,
>(
  provider: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof oauthAuthorizeApiV1AuthOauthProviderGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getOauthAuthorizeApiV1AuthOauthProviderGetQueryOptions(provider, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Handle OAuth callback, create session, and redirect to frontend with token.
 * @summary OAuth callback handler
 */
export type oauthCallbackApiV1AuthOauthProviderCallbackGetResponse302 = {
  data: unknown;
  status: 302;
};

export type oauthCallbackApiV1AuthOauthProviderCallbackGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};
export type oauthCallbackApiV1AuthOauthProviderCallbackGetResponseError = (
  | oauthCallbackApiV1AuthOauthProviderCallbackGetResponse302
  | oauthCallbackApiV1AuthOauthProviderCallbackGetResponse422
) & {
  headers: Headers;
};

export type oauthCallbackApiV1AuthOauthProviderCallbackGetResponse =
  oauthCallbackApiV1AuthOauthProviderCallbackGetResponseError;

export const getOauthCallbackApiV1AuthOauthProviderCallbackGetUrl = (
  provider: string,
  params?: OauthCallbackApiV1AuthOauthProviderCallbackGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/auth/oauth/${provider}/callback?${stringifiedParams}`
    : `/api/v1/auth/oauth/${provider}/callback`;
};

export const oauthCallbackApiV1AuthOauthProviderCallbackGet = async (
  provider: string,
  params?: OauthCallbackApiV1AuthOauthProviderCallbackGetParams,
  options?: RequestInit
): Promise<oauthCallbackApiV1AuthOauthProviderCallbackGetResponse> => {
  return customInstance<oauthCallbackApiV1AuthOauthProviderCallbackGetResponse>(
    getOauthCallbackApiV1AuthOauthProviderCallbackGetUrl(provider, params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getOauthCallbackApiV1AuthOauthProviderCallbackGetQueryKey = (
  provider?: string,
  params?: OauthCallbackApiV1AuthOauthProviderCallbackGetParams
) => {
  return [`/api/v1/auth/oauth/${provider}/callback`, ...(params ? [params] : [])] as const;
};

export const getOauthCallbackApiV1AuthOauthProviderCallbackGetQueryOptions = <
  TData = Awaited<ReturnType<typeof oauthCallbackApiV1AuthOauthProviderCallbackGet>>,
  TError = unknown | HTTPValidationError,
>(
  provider: string,
  params?: OauthCallbackApiV1AuthOauthProviderCallbackGetParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof oauthCallbackApiV1AuthOauthProviderCallbackGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getOauthCallbackApiV1AuthOauthProviderCallbackGetQueryKey(provider, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof oauthCallbackApiV1AuthOauthProviderCallbackGet>>
  > = ({ signal }) =>
    oauthCallbackApiV1AuthOauthProviderCallbackGet(provider, params, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!provider, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof oauthCallbackApiV1AuthOauthProviderCallbackGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type OauthCallbackApiV1AuthOauthProviderCallbackGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof oauthCallbackApiV1AuthOauthProviderCallbackGet>>
>;
export type OauthCallbackApiV1AuthOauthProviderCallbackGetQueryError =
  | unknown
  | HTTPValidationError;

/**
 * @summary OAuth callback handler
 */

export function useOauthCallbackApiV1AuthOauthProviderCallbackGet<
  TData = Awaited<ReturnType<typeof oauthCallbackApiV1AuthOauthProviderCallbackGet>>,
  TError = unknown | HTTPValidationError,
>(
  provider: string,
  params?: OauthCallbackApiV1AuthOauthProviderCallbackGetParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof oauthCallbackApiV1AuthOauthProviderCallbackGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getOauthCallbackApiV1AuthOauthProviderCallbackGetQueryOptions(
    provider,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Exchange a provider access token (from device flow) for a burntop session. Used by CLI.
 * @summary Exchange device flow token for session
 */
export type deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePostResponse200 = {
  data: SessionResponse;
  status: 200;
};

export type deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePostResponseSuccess =
  deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePostResponse200 & {
    headers: Headers;
  };
export type deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePostResponseError =
  deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePostResponse422 & {
    headers: Headers;
  };

export type deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePostResponse =
  | deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePostResponseSuccess
  | deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePostResponseError;

export const getDeviceFlowTokenExchangeApiV1AuthOauthProviderDevicePostUrl = (provider: string) => {
  return `/api/v1/auth/oauth/${provider}/device`;
};

export const deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePost = async (
  provider: string,
  deviceTokenExchangeRequest: DeviceTokenExchangeRequest,
  options?: RequestInit
): Promise<deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePostResponse> => {
  return customInstance<deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePostResponse>(
    getDeviceFlowTokenExchangeApiV1AuthOauthProviderDevicePostUrl(provider),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(deviceTokenExchangeRequest),
    }
  );
};

export const getDeviceFlowTokenExchangeApiV1AuthOauthProviderDevicePostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePost>>,
    TError,
    { provider: string; data: DeviceTokenExchangeRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePost>>,
  TError,
  { provider: string; data: DeviceTokenExchangeRequest },
  TContext
> => {
  const mutationKey = ['deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePost>>,
    { provider: string; data: DeviceTokenExchangeRequest }
  > = (props) => {
    const { provider, data } = props ?? {};

    return deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePost(provider, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeviceFlowTokenExchangeApiV1AuthOauthProviderDevicePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePost>>
>;
export type DeviceFlowTokenExchangeApiV1AuthOauthProviderDevicePostMutationBody =
  DeviceTokenExchangeRequest;
export type DeviceFlowTokenExchangeApiV1AuthOauthProviderDevicePostMutationError =
  HTTPValidationError;

/**
 * @summary Exchange device flow token for session
 */
export const useDeviceFlowTokenExchangeApiV1AuthOauthProviderDevicePost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePost>>,
    TError,
    { provider: string; data: DeviceTokenExchangeRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof deviceFlowTokenExchangeApiV1AuthOauthProviderDevicePost>>,
  TError,
  { provider: string; data: DeviceTokenExchangeRequest },
  TContext
> => {
  const mutationOptions =
    getDeviceFlowTokenExchangeApiV1AuthOauthProviderDevicePostMutationOptions(options);

  return useMutation(mutationOptions);
};
