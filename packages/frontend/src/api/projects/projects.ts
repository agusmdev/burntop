/**
 * Generated by orval v7.18.0 üç∫
 * Do not edit manually.
 * Burntop API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  GetUserProjectsApiV1UsersUsernameProjectsGetParams,
  HTTPValidationError,
  ProjectCreate,
  ProjectResponse,
  ProjectUpdate,
  UpdateProjectApiV1ProjectsProjectIdPatchParams,
} from '../generated.schemas';

import { customInstance } from '.././client';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Get all projects for a user by username.

Returns projects ordered by display_order and created_at.
This is a public endpoint - anyone can view a user's projects.

Note: This endpoint is mounted on the users router at /users/{username}/projects.

Args:
    username: Username to get projects for
    project_service: Project service instance
    skip: Number of records to skip (pagination)
    limit: Maximum number of records to return (max 100)

Returns:
    List of projects belonging to the user

Raises:
    NotFoundError: If user not found (404)
 * @summary Get User Projects
 */
export type getUserProjectsApiV1UsersUsernameProjectsGetResponse200 = {
  data: ProjectResponse[];
  status: 200;
};

export type getUserProjectsApiV1UsersUsernameProjectsGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type getUserProjectsApiV1UsersUsernameProjectsGetResponseSuccess =
  getUserProjectsApiV1UsersUsernameProjectsGetResponse200 & {
    headers: Headers;
  };
export type getUserProjectsApiV1UsersUsernameProjectsGetResponseError =
  getUserProjectsApiV1UsersUsernameProjectsGetResponse422 & {
    headers: Headers;
  };

export type getUserProjectsApiV1UsersUsernameProjectsGetResponse =
  | getUserProjectsApiV1UsersUsernameProjectsGetResponseSuccess
  | getUserProjectsApiV1UsersUsernameProjectsGetResponseError;

export const getGetUserProjectsApiV1UsersUsernameProjectsGetUrl = (
  username: string,
  params?: GetUserProjectsApiV1UsersUsernameProjectsGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/users/${username}/projects?${stringifiedParams}`
    : `/api/v1/users/${username}/projects`;
};

export const getUserProjectsApiV1UsersUsernameProjectsGet = async (
  username: string,
  params?: GetUserProjectsApiV1UsersUsernameProjectsGetParams,
  options?: RequestInit
): Promise<getUserProjectsApiV1UsersUsernameProjectsGetResponse> => {
  return customInstance<getUserProjectsApiV1UsersUsernameProjectsGetResponse>(
    getGetUserProjectsApiV1UsersUsernameProjectsGetUrl(username, params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetUserProjectsApiV1UsersUsernameProjectsGetQueryKey = (
  username?: string,
  params?: GetUserProjectsApiV1UsersUsernameProjectsGetParams
) => {
  return [`/api/v1/users/${username}/projects`, ...(params ? [params] : [])] as const;
};

export const getGetUserProjectsApiV1UsersUsernameProjectsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserProjectsApiV1UsersUsernameProjectsGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  params?: GetUserProjectsApiV1UsersUsernameProjectsGetParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserProjectsApiV1UsersUsernameProjectsGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetUserProjectsApiV1UsersUsernameProjectsGetQueryKey(username, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserProjectsApiV1UsersUsernameProjectsGet>>
  > = ({ signal }) =>
    getUserProjectsApiV1UsersUsernameProjectsGet(username, params, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!username, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserProjectsApiV1UsersUsernameProjectsGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserProjectsApiV1UsersUsernameProjectsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserProjectsApiV1UsersUsernameProjectsGet>>
>;
export type GetUserProjectsApiV1UsersUsernameProjectsGetQueryError = HTTPValidationError;

/**
 * @summary Get User Projects
 */

export function useGetUserProjectsApiV1UsersUsernameProjectsGet<
  TData = Awaited<ReturnType<typeof getUserProjectsApiV1UsersUsernameProjectsGet>>,
  TError = HTTPValidationError,
>(
  username: string,
  params?: GetUserProjectsApiV1UsersUsernameProjectsGetParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserProjectsApiV1UsersUsernameProjectsGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetUserProjectsApiV1UsersUsernameProjectsGetQueryOptions(
    username,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new project for the authenticated user.

Automatically fetches OG metadata (title, description, image, favicon) from the URL.
User can optionally override title and description.

Args:
    project_in: Project creation data with required URL
    current_user: Authenticated user
    project_service: Project service instance

Returns:
    Created project with OG metadata

Raises:
    UnauthorizedError: If not authenticated (401)
    BadRequestError: If URL is invalid or unreachable (400)
    ConflictError: If user already has a project with this URL (409)
 * @summary Create Project
 */
export type createProjectApiV1ProjectsPostResponse201 = {
  data: ProjectResponse;
  status: 201;
};

export type createProjectApiV1ProjectsPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type createProjectApiV1ProjectsPostResponseSuccess =
  createProjectApiV1ProjectsPostResponse201 & {
    headers: Headers;
  };
export type createProjectApiV1ProjectsPostResponseError =
  createProjectApiV1ProjectsPostResponse422 & {
    headers: Headers;
  };

export type createProjectApiV1ProjectsPostResponse =
  | createProjectApiV1ProjectsPostResponseSuccess
  | createProjectApiV1ProjectsPostResponseError;

export const getCreateProjectApiV1ProjectsPostUrl = () => {
  return `/api/v1/projects`;
};

export const createProjectApiV1ProjectsPost = async (
  projectCreate: ProjectCreate,
  options?: RequestInit
): Promise<createProjectApiV1ProjectsPostResponse> => {
  return customInstance<createProjectApiV1ProjectsPostResponse>(
    getCreateProjectApiV1ProjectsPostUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(projectCreate),
    }
  );
};

export const getCreateProjectApiV1ProjectsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProjectApiV1ProjectsPost>>,
    TError,
    { data: ProjectCreate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProjectApiV1ProjectsPost>>,
  TError,
  { data: ProjectCreate },
  TContext
> => {
  const mutationKey = ['createProjectApiV1ProjectsPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProjectApiV1ProjectsPost>>,
    { data: ProjectCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createProjectApiV1ProjectsPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateProjectApiV1ProjectsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProjectApiV1ProjectsPost>>
>;
export type CreateProjectApiV1ProjectsPostMutationBody = ProjectCreate;
export type CreateProjectApiV1ProjectsPostMutationError = HTTPValidationError;

/**
 * @summary Create Project
 */
export const useCreateProjectApiV1ProjectsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProjectApiV1ProjectsPost>>,
    TError,
    { data: ProjectCreate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof createProjectApiV1ProjectsPost>>,
  TError,
  { data: ProjectCreate },
  TContext
> => {
  const mutationOptions = getCreateProjectApiV1ProjectsPostMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Get a single project by ID.

This is a public endpoint - anyone can view a project.

Args:
    project_id: UUID of the project
    project_service: Project service instance

Returns:
    Project details

Raises:
    NotFoundError: If project not found (404)
 * @summary Get Project
 */
export type getProjectApiV1ProjectsProjectIdGetResponse200 = {
  data: ProjectResponse;
  status: 200;
};

export type getProjectApiV1ProjectsProjectIdGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type getProjectApiV1ProjectsProjectIdGetResponseSuccess =
  getProjectApiV1ProjectsProjectIdGetResponse200 & {
    headers: Headers;
  };
export type getProjectApiV1ProjectsProjectIdGetResponseError =
  getProjectApiV1ProjectsProjectIdGetResponse422 & {
    headers: Headers;
  };

export type getProjectApiV1ProjectsProjectIdGetResponse =
  | getProjectApiV1ProjectsProjectIdGetResponseSuccess
  | getProjectApiV1ProjectsProjectIdGetResponseError;

export const getGetProjectApiV1ProjectsProjectIdGetUrl = (projectId: string) => {
  return `/api/v1/projects/${projectId}`;
};

export const getProjectApiV1ProjectsProjectIdGet = async (
  projectId: string,
  options?: RequestInit
): Promise<getProjectApiV1ProjectsProjectIdGetResponse> => {
  return customInstance<getProjectApiV1ProjectsProjectIdGetResponse>(
    getGetProjectApiV1ProjectsProjectIdGetUrl(projectId),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetProjectApiV1ProjectsProjectIdGetQueryKey = (projectId?: string) => {
  return [`/api/v1/projects/${projectId}`] as const;
};

export const getGetProjectApiV1ProjectsProjectIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjectApiV1ProjectsProjectIdGet>>,
  TError = HTTPValidationError,
>(
  projectId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getProjectApiV1ProjectsProjectIdGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetProjectApiV1ProjectsProjectIdGetQueryKey(projectId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjectApiV1ProjectsProjectIdGet>>> = ({
    signal,
  }) => getProjectApiV1ProjectsProjectIdGet(projectId, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!projectId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProjectApiV1ProjectsProjectIdGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetProjectApiV1ProjectsProjectIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProjectApiV1ProjectsProjectIdGet>>
>;
export type GetProjectApiV1ProjectsProjectIdGetQueryError = HTTPValidationError;

/**
 * @summary Get Project
 */

export function useGetProjectApiV1ProjectsProjectIdGet<
  TData = Awaited<ReturnType<typeof getProjectApiV1ProjectsProjectIdGet>>,
  TError = HTTPValidationError,
>(
  projectId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getProjectApiV1ProjectsProjectIdGet>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetProjectApiV1ProjectsProjectIdGetQueryOptions(projectId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update a project.

Only the project owner can update it. If the URL is changed and
refetch_metadata is True, OG metadata will be refetched.

Args:
    project_id: UUID of the project to update
    project_in: Project update data (all fields optional)
    current_user: Authenticated user
    project_service: Project service instance
    refetch_metadata: Whether to refetch OG metadata if URL changed

Returns:
    Updated project

Raises:
    UnauthorizedError: If not authenticated (401)
    ForbiddenError: If user doesn't own the project (403)
    NotFoundError: If project not found (404)
    ConflictError: If new URL already exists for this user (409)
 * @summary Update Project
 */
export type updateProjectApiV1ProjectsProjectIdPatchResponse200 = {
  data: ProjectResponse;
  status: 200;
};

export type updateProjectApiV1ProjectsProjectIdPatchResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type updateProjectApiV1ProjectsProjectIdPatchResponseSuccess =
  updateProjectApiV1ProjectsProjectIdPatchResponse200 & {
    headers: Headers;
  };
export type updateProjectApiV1ProjectsProjectIdPatchResponseError =
  updateProjectApiV1ProjectsProjectIdPatchResponse422 & {
    headers: Headers;
  };

export type updateProjectApiV1ProjectsProjectIdPatchResponse =
  | updateProjectApiV1ProjectsProjectIdPatchResponseSuccess
  | updateProjectApiV1ProjectsProjectIdPatchResponseError;

export const getUpdateProjectApiV1ProjectsProjectIdPatchUrl = (
  projectId: string,
  params?: UpdateProjectApiV1ProjectsProjectIdPatchParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/projects/${projectId}?${stringifiedParams}`
    : `/api/v1/projects/${projectId}`;
};

export const updateProjectApiV1ProjectsProjectIdPatch = async (
  projectId: string,
  projectUpdate: ProjectUpdate,
  params?: UpdateProjectApiV1ProjectsProjectIdPatchParams,
  options?: RequestInit
): Promise<updateProjectApiV1ProjectsProjectIdPatchResponse> => {
  return customInstance<updateProjectApiV1ProjectsProjectIdPatchResponse>(
    getUpdateProjectApiV1ProjectsProjectIdPatchUrl(projectId, params),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(projectUpdate),
    }
  );
};

export const getUpdateProjectApiV1ProjectsProjectIdPatchMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProjectApiV1ProjectsProjectIdPatch>>,
    TError,
    {
      projectId: string;
      data: ProjectUpdate;
      params?: UpdateProjectApiV1ProjectsProjectIdPatchParams;
    },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProjectApiV1ProjectsProjectIdPatch>>,
  TError,
  {
    projectId: string;
    data: ProjectUpdate;
    params?: UpdateProjectApiV1ProjectsProjectIdPatchParams;
  },
  TContext
> => {
  const mutationKey = ['updateProjectApiV1ProjectsProjectIdPatch'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProjectApiV1ProjectsProjectIdPatch>>,
    {
      projectId: string;
      data: ProjectUpdate;
      params?: UpdateProjectApiV1ProjectsProjectIdPatchParams;
    }
  > = (props) => {
    const { projectId, data, params } = props ?? {};

    return updateProjectApiV1ProjectsProjectIdPatch(projectId, data, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateProjectApiV1ProjectsProjectIdPatchMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateProjectApiV1ProjectsProjectIdPatch>>
>;
export type UpdateProjectApiV1ProjectsProjectIdPatchMutationBody = ProjectUpdate;
export type UpdateProjectApiV1ProjectsProjectIdPatchMutationError = HTTPValidationError;

/**
 * @summary Update Project
 */
export const useUpdateProjectApiV1ProjectsProjectIdPatch = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProjectApiV1ProjectsProjectIdPatch>>,
    TError,
    {
      projectId: string;
      data: ProjectUpdate;
      params?: UpdateProjectApiV1ProjectsProjectIdPatchParams;
    },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateProjectApiV1ProjectsProjectIdPatch>>,
  TError,
  {
    projectId: string;
    data: ProjectUpdate;
    params?: UpdateProjectApiV1ProjectsProjectIdPatchParams;
  },
  TContext
> => {
  const mutationOptions = getUpdateProjectApiV1ProjectsProjectIdPatchMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Delete a project (soft delete).

Only the project owner can delete it.

Args:
    project_id: UUID of the project to delete
    current_user: Authenticated user
    project_service: Project service instance

Returns:
    None (204 No Content)

Raises:
    UnauthorizedError: If not authenticated (401)
    ForbiddenError: If user doesn't own the project (403)
    NotFoundError: If project not found (404)
 * @summary Delete Project
 */
export type deleteProjectApiV1ProjectsProjectIdDeleteResponse204 = {
  data: void;
  status: 204;
};

export type deleteProjectApiV1ProjectsProjectIdDeleteResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type deleteProjectApiV1ProjectsProjectIdDeleteResponseSuccess =
  deleteProjectApiV1ProjectsProjectIdDeleteResponse204 & {
    headers: Headers;
  };
export type deleteProjectApiV1ProjectsProjectIdDeleteResponseError =
  deleteProjectApiV1ProjectsProjectIdDeleteResponse422 & {
    headers: Headers;
  };

export type deleteProjectApiV1ProjectsProjectIdDeleteResponse =
  | deleteProjectApiV1ProjectsProjectIdDeleteResponseSuccess
  | deleteProjectApiV1ProjectsProjectIdDeleteResponseError;

export const getDeleteProjectApiV1ProjectsProjectIdDeleteUrl = (projectId: string) => {
  return `/api/v1/projects/${projectId}`;
};

export const deleteProjectApiV1ProjectsProjectIdDelete = async (
  projectId: string,
  options?: RequestInit
): Promise<deleteProjectApiV1ProjectsProjectIdDeleteResponse> => {
  return customInstance<deleteProjectApiV1ProjectsProjectIdDeleteResponse>(
    getDeleteProjectApiV1ProjectsProjectIdDeleteUrl(projectId),
    {
      ...options,
      method: 'DELETE',
    }
  );
};

export const getDeleteProjectApiV1ProjectsProjectIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProjectApiV1ProjectsProjectIdDelete>>,
    TError,
    { projectId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProjectApiV1ProjectsProjectIdDelete>>,
  TError,
  { projectId: string },
  TContext
> => {
  const mutationKey = ['deleteProjectApiV1ProjectsProjectIdDelete'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProjectApiV1ProjectsProjectIdDelete>>,
    { projectId: string }
  > = (props) => {
    const { projectId } = props ?? {};

    return deleteProjectApiV1ProjectsProjectIdDelete(projectId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteProjectApiV1ProjectsProjectIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProjectApiV1ProjectsProjectIdDelete>>
>;

export type DeleteProjectApiV1ProjectsProjectIdDeleteMutationError = HTTPValidationError;

/**
 * @summary Delete Project
 */
export const useDeleteProjectApiV1ProjectsProjectIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProjectApiV1ProjectsProjectIdDelete>>,
    TError,
    { projectId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteProjectApiV1ProjectsProjectIdDelete>>,
  TError,
  { projectId: string },
  TContext
> => {
  const mutationOptions = getDeleteProjectApiV1ProjectsProjectIdDeleteMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Refresh OG metadata for an existing project.

Refetches og:image, og:description, and favicon from the project URL.
Only updates metadata fields if they were originally empty.

Args:
    project_id: UUID of the project
    current_user: Authenticated user
    project_service: Project service instance

Returns:
    Updated project with fresh metadata

Raises:
    UnauthorizedError: If not authenticated (401)
    ForbiddenError: If user doesn't own the project (403)
    NotFoundError: If project not found (404)
    BadRequestError: If URL is unreachable (400)
 * @summary Refresh Project Metadata
 */
export type refreshProjectMetadataApiV1ProjectsProjectIdRefreshPostResponse200 = {
  data: ProjectResponse;
  status: 200;
};

export type refreshProjectMetadataApiV1ProjectsProjectIdRefreshPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type refreshProjectMetadataApiV1ProjectsProjectIdRefreshPostResponseSuccess =
  refreshProjectMetadataApiV1ProjectsProjectIdRefreshPostResponse200 & {
    headers: Headers;
  };
export type refreshProjectMetadataApiV1ProjectsProjectIdRefreshPostResponseError =
  refreshProjectMetadataApiV1ProjectsProjectIdRefreshPostResponse422 & {
    headers: Headers;
  };

export type refreshProjectMetadataApiV1ProjectsProjectIdRefreshPostResponse =
  | refreshProjectMetadataApiV1ProjectsProjectIdRefreshPostResponseSuccess
  | refreshProjectMetadataApiV1ProjectsProjectIdRefreshPostResponseError;

export const getRefreshProjectMetadataApiV1ProjectsProjectIdRefreshPostUrl = (
  projectId: string
) => {
  return `/api/v1/projects/${projectId}/refresh`;
};

export const refreshProjectMetadataApiV1ProjectsProjectIdRefreshPost = async (
  projectId: string,
  options?: RequestInit
): Promise<refreshProjectMetadataApiV1ProjectsProjectIdRefreshPostResponse> => {
  return customInstance<refreshProjectMetadataApiV1ProjectsProjectIdRefreshPostResponse>(
    getRefreshProjectMetadataApiV1ProjectsProjectIdRefreshPostUrl(projectId),
    {
      ...options,
      method: 'POST',
    }
  );
};

export const getRefreshProjectMetadataApiV1ProjectsProjectIdRefreshPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshProjectMetadataApiV1ProjectsProjectIdRefreshPost>>,
    TError,
    { projectId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof refreshProjectMetadataApiV1ProjectsProjectIdRefreshPost>>,
  TError,
  { projectId: string },
  TContext
> => {
  const mutationKey = ['refreshProjectMetadataApiV1ProjectsProjectIdRefreshPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refreshProjectMetadataApiV1ProjectsProjectIdRefreshPost>>,
    { projectId: string }
  > = (props) => {
    const { projectId } = props ?? {};

    return refreshProjectMetadataApiV1ProjectsProjectIdRefreshPost(projectId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RefreshProjectMetadataApiV1ProjectsProjectIdRefreshPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof refreshProjectMetadataApiV1ProjectsProjectIdRefreshPost>>
>;

export type RefreshProjectMetadataApiV1ProjectsProjectIdRefreshPostMutationError =
  HTTPValidationError;

/**
 * @summary Refresh Project Metadata
 */
export const useRefreshProjectMetadataApiV1ProjectsProjectIdRefreshPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshProjectMetadataApiV1ProjectsProjectIdRefreshPost>>,
    TError,
    { projectId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof refreshProjectMetadataApiV1ProjectsProjectIdRefreshPost>>,
  TError,
  { projectId: string },
  TContext
> => {
  const mutationOptions =
    getRefreshProjectMetadataApiV1ProjectsProjectIdRefreshPostMutationOptions(options);

  return useMutation(mutationOptions);
};
